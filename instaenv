#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Cmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD';
  use strict;
  use warnings;
  use 5.006;
  
  package App::Cmd;
  {
    $App::Cmd::VERSION = '0.323';
  }
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  # ABSTRACT: write command line apps with less suffering
  
  use File::Basename ();
  use Module::Pluggable::Object ();
  use Class::Load ();
  
  use Sub::Exporter -setup => {
    collectors => {
      -ignore  => \'_setup_ignore',
      -command => \'_setup_command',
      -run     => sub {
        warn "using -run to run your command is deprecated\n";
        $_[1]->{class}->run; 1
      },
    },
  };
  
  sub _setup_command {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -command setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    {
      my $base = $self->_default_command_base;
      Class::Load::load_class($base);
      no strict 'refs';
      push @{"$into\::ISA"}, $base;
    }
  
    $self->_register_command($into);
  
    for my $plugin ($self->_plugin_plugins) {
      $plugin->import_from_plugin({ into => $into });
    }
  
    1;
  }
  
  sub _setup_ignore {
    my ($self, $val, $data ) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -ignore setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    $self->_register_ignore($into);
  
    1;
  }
  
  sub _plugin_plugins { return }
  
  
  sub new {
    my ($class, $arg) = @_;
  
    my $arg0 = $0;
    my $base = File::Basename::basename $arg0;
  
    my $self = {
      command   => $class->_command($arg),
      arg0      => $base,
      full_arg0 => $arg0,
    };
  
    bless $self => $class;
  }
  
  # effectively, returns the command-to-plugin mapping guts of a Cmd
  # if called on a class or on a Cmd with no mapping, construct a new hashref
  # suitable for use as the object's mapping
  sub _command {
    my ($self, $arg) = @_;
    return $self->{command} if ref $self and $self->{command};
  
    # TODO _default_command_base can be wrong if people are not using
    # ::Setup and have no ::Command :(
    #
    #  my $want_isa = $self->_default_command_base;
    # -- kentnl, 2010-12
     my $want_isa = 'App::Cmd::Command';
  
    my %plugin;
    for my $plugin ($self->_plugins) {
  
      Class::Load::load_class($plugin);
  
      # relies on either the plugin itself registering as ignored
      # during compile ( use MyApp::Cmd -ignore )
      # or being explicitly registered elsewhere ( blacklisted )
      # via $app_cmd->_register_ignore( $class )
      #  -- kentnl, 2011-09
      next if $self->should_ignore( $plugin );
  
      die "$plugin is not a " . $want_isa
        unless $plugin->isa($want_isa);
  
      next unless $plugin->can("command_names");
  
      foreach my $command (map { lc } $plugin->command_names) {
        die "two plugins for command $command: $plugin and $plugin{$command}\n"
          if exists $plugin{$command};
  
        $plugin{$command} = $plugin;
      }
    }
  
    $self->_load_default_plugin($_, $arg, \%plugin) for qw(commands help version);
  
    if ($self->allow_any_unambiguous_abbrev) {
      # add abbreviations to list of authorized commands
      require Text::Abbrev;
      my %abbrev = Text::Abbrev::abbrev( keys %plugin );
      @plugin{ keys %abbrev } = @plugin{ values %abbrev };
    }
  
    return \%plugin;
  }
  
  # ->_plugins won't be called more than once on any given App::Cmd, but since
  # finding plugins can be a bit expensive, we'll do a lousy cache here.
  # -- rjbs, 2007-10-09
  my %plugins_for;
  sub _plugins {
    my ($self) = @_;
    my $class = ref $self || $self;
  
    return @{ $plugins_for{$class} } if $plugins_for{$class};
  
    my $finder = Module::Pluggable::Object->new(
      search_path => $self->plugin_search_path,
      $self->_module_pluggable_options,
    );
  
    my @plugins = $finder->plugins;
    $plugins_for{$class} = \@plugins;
  
    return @plugins;
  }
  
  sub _register_command {
    my ($self, $cmd_class) = @_;
    $self->_plugins;
  
    my $class = ref $self || $self;
    push @{ $plugins_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $plugins_for{ $class } };
  }
  
  my %ignored_for;
  
  sub should_ignore {
    my ( $self , $cmd_class ) = @_;
    my $class = ref $self || $self;
    for ( @{ $ignored_for{ $class } } ) {
      return 1 if $_ eq $cmd_class;
    }
    return;
  }
  
  sub _register_ignore {
    my ($self, $cmd_class) = @_;
    my $class = ref $self || $self;
    push @{ $ignored_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $ignored_for{ $class } };
  }
  
  sub _module_pluggable_options {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return;
  }
  
  # load one of the stock plugins, unless requested to squash; unlike normal
  # plugin loading, command-to-plugin mapping conflicts are silently ignored
  sub _load_default_plugin {
    my ($self, $plugin_name, $arg, $plugin_href) = @_;
    unless ($arg->{"no_$plugin_name\_plugin"}) {
      my $plugin = "App::Cmd::Command::$plugin_name";
      Class::Load::load_class($plugin);
      for my $command (map { lc } $plugin->command_names) {
        $plugin_href->{$command} ||= $plugin;
      }
    }
  }
  
  
  sub run {
    my ($self) = @_;
  
    # We should probably use Class::Default.
    $self = $self->new unless ref $self;
  
    # prepare the command we're going to run...
    my @argv = $self->prepare_args();
    my ($cmd, $opt, @args) = $self->prepare_command(@argv);
  
    # ...and then run it
    $self->execute_command($cmd, $opt, @args);
  }
  
  
  sub prepare_args {
    my ($self) = @_;
    return scalar(@ARGV)
      ? (@ARGV)
      : (@{$self->default_args});
  }
  
  
  use constant default_args => [];
  
  
  sub arg0      { $_[0]->{arg0} }
  sub full_arg0 { $_[0]->{full_arg0} }
  
  
  sub prepare_command {
    my ($self, @args) = @_;
  
    # figure out first-level dispatch
    my ($command, $opt, @sub_args) = $self->get_command(@args);
  
    # set up the global options (which we just determined)
    $self->set_global_options($opt);
  
    # find its plugin or else call default plugin (default default is help)
    if ($command) {
      $self->_prepare_command($command, $opt, @sub_args);
    } else {
      $self->_prepare_default_command($opt, @sub_args);
    }
  }
  
  sub _prepare_command {
    my ($self, $command, $opt, @args) = @_;
    if (my $plugin = $self->plugin_for($command)) {
      return $plugin->prepare($self, @args);
    } else {
      return $self->_bad_command($command, $opt, @args);
    }
  }
  
  sub _prepare_default_command {
    my ($self, $opt, @sub_args) = @_;
    $self->_prepare_command($self->default_command, $opt, @sub_args);
  }
  
  sub _bad_command {
    my ($self, $command, $opt, @args) = @_;
    print "Unrecognized command: $command.\n\nUsage:\n" if defined($command);
  
    # This should be class data so that, in Bizarro World, two App::Cmds will not
    # conflict.
    our $_bad++;
    $self->prepare_command(qw(commands --stderr));
  }
  
  END { exit 1 if our $_bad };
  
  
  sub default_command { "help" }
  
  
  sub execute_command {
    my ($self, $cmd, $opt, @args) = @_;
  
    local our $active_cmd = $cmd;
  
    $cmd->validate_args($opt, \@args);
    $cmd->execute($opt, \@args);
  }
  
  
  sub _default_command_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Command";
  }
  
  sub _default_plugin_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Plugin";
  }
  
  sub plugin_search_path {
    my ($self) = @_;
  
    my $dcb = $self->_default_command_base;
    my $ccb = $dcb eq 'App::Cmd::Command'
            ? $self->App::Cmd::_default_command_base
            : $self->_default_command_base;
  
    my @default = ($ccb, $self->_default_plugin_base);
  
    if (ref $self) {
      return $self->{plugin_search_path} ||= \@default;
    } else {
      return \@default;
    }
  }
  
  
  sub allow_any_unambiguous_abbrev { return 0 }
  
  
  sub global_options {
  	my $self = shift;
  	return $self->{global_options} ||= {} if ref $self;
    return {};
  }
  
  
  sub set_global_options {
    my ($self, $opt) = @_;
    return $self->{global_options} = $opt;
  }
  
  
  sub command_names {
    my ($self) = @_;
    keys %{ $self->_command };
  }
  
  
  sub command_plugins {
    my ($self) = @_;
    my %seen = map {; $_ => 1 } values %{ $self->_command };
    keys %seen;
  }
  
  
  sub plugin_for {
    my ($self, $command) = @_;
    return unless $command;
    return unless exists $self->_command->{ $command };
  
    return $self->_command->{ $command };
  }
  
  
  sub get_command {
    my ($self, @args) = @_;
  
    my ($opt, $args, %fields)
      = $self->_process_args(\@args, $self->_global_option_processing_params);
  
    my ($command, $rest) = $self->_cmd_from_args($args);
  
    $self->{usage} = $fields{usage};
  
    return ($command, $opt, @$rest);
  }
  
  sub _cmd_from_args {
    my ($self, $args) = @_;
  
    my $command = shift @$args;
    return ($command, $args);
  }
  
  sub _global_option_processing_params {
    my ($self, @args) = @_;
  
    return (
      $self->usage_desc(@args),
      $self->global_opt_spec(@args),
      { getopt_conf => [qw/pass_through/] },
    );
  }
  
  
  sub usage { $_[0]{usage} };
  
  
  sub usage_desc {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return "%c <command> %o";
  }
  
  
  sub global_opt_spec {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return;
  }
  
  
  sub usage_error {
    my ($self, $error) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    my $text = $self->usage->text;
    $text =~ s/\A(\s+)/!/;
    return $text;
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd - write command line apps with less suffering
  
  =head1 VERSION
  
  version 0.323
  
  =head1 SYNOPSIS
  
  in F<yourcmd>:
  
    use YourApp;
    YourApp->run;
  
  in F<YourApp.pm>:
  
    package YourApp;
    use App::Cmd::Setup -app;
    1;
  
  in F<YourApp/Command/blort.pm>:
  
    package YourApp::Command::blort;
    use YourApp -command;
    use strict; use warnings;
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ yourcmd blort --recheck
  
    All blorts successful.
  
  =head1 DESCRIPTION
  
  App::Cmd is intended to make it easy to write complex command-line applications
  without having to think about most of the annoying things usually involved.
  
  For information on how to start using App::Cmd, see L<App::Cmd::Tutorial>.
  
  =head1 METHODS
  
  =head2 new
  
    my $cmd = App::Cmd->new(\%arg);
  
  This method returns a new App::Cmd object.  During initialization, command
  plugins will be loaded.
  
  Valid arguments are:
  
    no_commands_plugin - if true, the command list plugin is not added
  
    no_help_plugin     - if true, the help plugin is not added
  
    no_version_plugin  - if true, the version plugin is not added
  
    plugin_search_path - The path to search for commands in. Defaults to
                         results of plugin_search_path method
  
  If C<no_commands_plugin> is not given, L<App::Cmd::Command::commands> will be
  required, and it will be registered to handle all of its command names not
  handled by other plugins.
  
  If C<no_help_plugin> is not given, L<App::Cmd::Command::help> will be required,
  and it will be registered to handle all of its command names not handled by
  other plugins. B<Note:> "help" is the default command, so if you do not load
  the default help plugin, you should provide your own or override the
  C<default_command> method.
  
  If C<no_version_plugin> is not given, L<App::Cmd::Command::version> will be
  required to show the application's version with command C<--version>. The
  version command is not included in the command list.
  
  =head2 run
  
    $cmd->run;
  
  This method runs the application.  If called the class, it will instantiate a
  new App::Cmd object to run.
  
  It determines the requested command (generally by consuming the first
  command-line argument), finds the plugin to handle that command, parses the
  remaining arguments according to that plugin's rules, and runs the plugin.
  
  It passes the contents of the global argument array (C<@ARGV>) to
  L</C<prepare_command>>, but C<@ARGV> is not altered by running an App::Cmd.
  
  =head2 prepare_args
  
  Normally App::Cmd uses C<@ARGV> for its commandline arguments. You can override
  this method to change that behavior for testing or otherwise.
  
  =head2 default_args
  
  If C<L</prepare_args>> is not changed and there are no arguments in C<@ARGV>,
  this method is called and should return an arrayref to be used as the arguments
  to the program.  By default, it returns an empty arrayref.
  
  =head2 arg0
  
  =head2 full_arg0
  
    my $program_name = $app->arg0;
  
    my $full_program_name = $app->full_arg0;
  
  These methods return the name of the program invoked to run this application.
  This is determined by inspecting C<$0> when the App::Cmd object is
  instantiated, so it's probably correct, but doing weird things with App::Cmd
  could lead to weird values from these methods.
  
  If the program was run like this:
  
    knight!rjbs$ ~/bin/rpg dice 3d6
  
  Then the methods return:
  
    arg0      - rpg
    full_arg0 - /Users/rjbs/bin/rpg
  
  These values are captured when the App::Cmd object is created, so it is safe to
  assign to C<$0> later.
  
  =head2 prepare_command
  
    my ($cmd, $opt, @args) = $app->prepare_command(@ARGV);
  
  This method will load the plugin for the requested command, use its options to
  parse the command line arguments, and eventually return everything necessary to
  actually execute the command.
  
  =head2 default_command
  
  This method returns the name of the command to run if none is given on the
  command line.  The default default is "help"
  
  =head2 execute_command
  
    $app->execute_command($cmd, \%opt, @args);
  
  This method will invoke C<validate_args> and then C<run> on C<$cmd>.
  
  =head2 plugin_search_path
  
  This method returns the plugin_search_path as set.  The default implementation,
  if called on "YourApp::Cmd" will return "YourApp::Cmd::Command"
  
  This is a method because it's fun to override it with, for example:
  
    use constant plugin_search_path => __PACKAGE__;
  
  =head2 allow_any_unambiguous_abbrev
  
  If this method returns true (which, by default, it does I<not>), then any
  unambiguous abbreviation for a registered command name will be allowed as a
  means to use that command.  For example, given the following commands:
  
    reticulate
    reload
    rasterize
  
  Then the user could use C<ret> for C<reticulate> or C<ra> for C<rasterize> and
  so on.
  
  =head2 global_options
  
    if ($cmd->app->global_options->{verbose}) { ... }
  
  This method returns the running application's global options as a hashref.  If
  there are no options specified, an empty hashref is returned.
  
  =head2 set_global_options
  
    $app->set_global_options(\%opt);
  
  This method sets the global options.
  
  =head2 command_names
  
    my @names = $cmd->command_names;
  
  This returns the commands names which the App::Cmd object will handle.
  
  =head2 command_plugins
  
    my @plugins = $cmd->command_plugins;
  
  This method returns the package names of the plugins that implement the
  App::Cmd object's commands.
  
  =head2 plugin_for
  
    my $plugin = $cmd->plugin_for($command);
  
  This method returns the plugin (module) for the given command.  If no plugin
  implements the command, it returns false.
  
  =head2 get_command
  
    my ($command_name, $opt, @args) = $app->get_command(@args);
  
  Process arguments and into a command name and (optional) global options.
  
  =head2 usage
  
    print $self->app->usage->text;
  
  Returns the usage object for the global options.
  
  =head2 usage_desc
  
  The top level usage line. Looks something like
  
    "yourapp <command> [options]"
  
  =head2 global_opt_spec
  
  Returns an empty list. Can be overridden for pre-dispatch option processing.
  This is useful for flags like --verbose.
  
  =head2 usage_error
  
    $self->usage_error("Something's wrong!");
  
  Used to die with nice usage output, during C<validate_args>.
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  publish and bring in Log::Speak (simple quiet/verbose output)
  
  =item *
  
  publish and use our internal enhanced describe_options
  
  =item *
  
  publish and use our improved simple input routines
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD

$fatpacked{"App/Cmd/ArgProcessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_ARGPROCESSOR';
  use strict;
  use warnings;
  
  package App::Cmd::ArgProcessor;
  {
    $App::Cmd::ArgProcessor::VERSION = '0.323';
  }
  # ABSTRACT: App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  sub _process_args {
    my ($class, $args, @params) = @_;
    local @ARGV = @$args;
  
    require Getopt::Long::Descriptive;
    Getopt::Long::Descriptive->VERSION(0.084);
  
    my ($opt, $usage) = Getopt::Long::Descriptive::describe_options(@params);
  
    return (
      $opt,
      [ @ARGV ], # whatever remained
      usage => $usage,
    );
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::ArgProcessor - App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  =head1 VERSION
  
  version 0.323
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_ARGPROCESSOR

$fatpacked{"App/Cmd/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND';
  use strict;
  use warnings;
  
  package App::Cmd::Command;
  {
    $App::Cmd::Command::VERSION = '0.323';
  }
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  
  # ABSTRACT: a base class for App::Cmd commands
  
  use Carp ();
  
  
  sub prepare {
    my ($class, $app, @args) = @_;
  
    my ($opt, $args, %fields)
      = $class->_process_args(\@args, $class->_option_processing_params($app));
  
    return (
      $class->new({ app => $app, %fields }),
      $opt,
      @$args,
    );
  }
  
  sub _option_processing_params {
    my ($class, @args) = @_;
  
    return (
      $class->usage_desc(@args),
      $class->opt_spec(@args),
    );
  }
  
  
  sub new {
    my ($class, $arg) = @_;
    bless $arg => $class;
  }
  
  
  sub execute {
    my $class = shift;
  
    if (my $run = $class->can('run')) {
      warn "App::Cmd::Command subclasses should implement ->execute not ->run"
        if $ENV{HARNESS_ACTIVE};
  
      return $class->$run(@_);
    }
  
    Carp::croak ref($class) . " does not implement mandatory method 'execute'\n";
  }
  
  
  sub app { $_[0]->{app}; }
  
  
  sub usage { $_[0]->{usage}; }
  
  
  sub command_names {
    # from UNIVERSAL::moniker
    (ref( $_[0] ) || $_[0]) =~ /([^:]+)$/;
    return lc $1;
  }
  
  
  sub usage_desc {
    my ($self) = @_;
  
    my ($command) = $self->command_names;
    return "%c $command %o"
  }
  
  
  sub opt_spec {
    return;
  }
  
  
  sub validate_args { }
  
  
  sub usage_error {
    my ( $self, $error ) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    local $@;
    join "\n", eval { $self->app->_usage_text }, eval { $self->usage->text };
  }
  
  
  # stolen from ExtUtils::MakeMaker
  sub abstract {
    my ($class) = @_;
    $class = ref $class if ref $class;
  
    my $result;
    my $weaver_abstract;
  
    # classname to filename
    (my $pm_file = $class) =~ s!::!/!g;
    $pm_file .= '.pm';
    $pm_file = $INC{$pm_file} or return "(unknown)";
  
    # if the pm file exists, open it and parse it
    open my $fh, "<", $pm_file or return "(unknown)";
  
    local $/ = "\n";
    my $inpod;
  
    while (local $_ = <$fh>) {
      # =cut toggles, it doesn't end :-/
      $inpod = /^=cut/ ? !$inpod : $inpod || /^=(?!cut)/;
  
      if (/#+\s*ABSTRACT: (.*)/){
        # takes ABSTRACT: ... if no POD defined yet
        $weaver_abstract = $1;
      }
  
      next unless $inpod;
      chomp;
  
      next unless /^(?:$class\s-\s)(.*)/;
  
      $result = $1;
      last;
    }
  
    return $result || $weaver_abstract || "(unknown)";
  }
  
  
  sub description { '' }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command - a base class for App::Cmd commands
  
  =head1 VERSION
  
  version 0.323
  
  =head1 METHODS
  
  =head2 prepare
  
    my ($cmd, $opt, $args) = $class->prepare($app, @args);
  
  This method is the primary way in which App::Cmd::Command objects are built.
  Given the remaining command line arguments meant for the command, it returns
  the Command object, parsed options (as a hashref), and remaining arguments (as
  an arrayref).
  
  In the usage above, C<$app> is the App::Cmd object that is invoking the
  command.
  
  =head2 new
  
  This returns a new instance of the command plugin.  Probably only C<prepare>
  should use this.
  
  =head2 execute
  
    $command_plugin->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  If no C<execute> method is defined, it will try to call C<run> -- but it will
  warn about this behavior during testing, to remind you to fix the method name!
  
  =head2 app
  
  This method returns the App::Cmd object into which this command is plugged.
  
  =head2 usage
  
  This method returns the usage object for this command.  (See
  L<Getopt::Long::Descriptive>).
  
  =head2 command_names
  
  This method returns a list of command names handled by this plugin. The
  first item returned is the 'canonical' name of the command.
  
  If this method is not overridden by an App::Cmd::Command subclass, it will
  return the last part of the plugin's package name, converted to lowercase.
  For example, YourApp::Cmd::Command::Init will, by default, handle the command
  "init".
  
  Subclasses should generally get the superclass value of C<command_names>
  and then append aliases.
  
  =head2 usage_desc
  
  This method should be overridden to provide a usage string.  (This is the first
  argument passed to C<describe_options> from Getopt::Long::Descriptive.)
  
  If not overridden, it returns "%c COMMAND %o";  COMMAND is the first item in
  the result of the C<command_names> method.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $command_plugin->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>, below) if they are invalid,
  or it may do nothing to allow processing to continue.
  
  =head2 usage_error
  
    $self->usage_error("This command must not be run by root!");
  
  This method should be called to die with human-friendly usage output, during
  C<validate_args>.
  
  =head2 abstract
  
  This method returns a short description of the command's purpose.  If this
  method is not overridden, it will return the abstract from the module's Pod.
  If it can't find the abstract, it will look for a comment starting with
  "ABSTRACT:" like the ones used by L<Pod::Weaver::Section::Name>.
  
  =head2 description
  
  This method should be overridden to provide full option description. It
  is used by the built-in L<help|App::Cmd::Command::help> command.
  
  If not overridden, it returns an empty string.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND

$fatpacked{"App/Cmd/Command/commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_COMMANDS';
  use strict;
  use warnings;
  
  package App::Cmd::Command::commands;
  {
    $App::Cmd::Command::commands::VERSION = '0.323';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' };
  
  # ABSTRACT: list the application's commands
  
  
  sub execute {
    my ($self, $opt, $args) = @_;
  
    my $target = $opt->stderr ? *STDERR : *STDOUT;
  
    local $@;
    eval { print { $target } $self->app->_usage_text . "\n" };
  
    print { $target } "Available commands:\n\n";
  
    my @primary_commands =
      grep { $_ ne 'version' }
      map { ($_->command_names)[0] }
      $self->app->command_plugins;
  
    my @cmd_groups = $self->sort_commands(@primary_commands);
  
    my $fmt_width = 0;
    for (@primary_commands) { $fmt_width = length if length > $fmt_width }
    $fmt_width += 2; # pretty
  
    foreach my $cmd_set (@cmd_groups) {
      for my $command (@$cmd_set) {
        my $abstract = $self->app->plugin_for($command)->abstract;
        printf { $target } "%${fmt_width}s: %s\n", $command, $abstract;
      }
      print { $target } "\n";
    }
  }
  
  
  sub sort_commands {
    my ($self, @commands) = @_;
  
    my $float = qr/^(?:help|commands)$/;
  
    my @head = sort grep { $_ =~ $float } @commands;
    my @tail = sort grep { $_ !~ $float } @commands;
  
    return (\@head, \@tail);
  }
  
  sub opt_spec {
    return (
      [ 'stderr' => 'hidden' ],
    );
  }
  
  sub description {
    "This command will list all of commands available and their abstracts.\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::commands - list the application's commands
  
  =head1 VERSION
  
  version 0.323
  
  =head1 DESCRIPTION
  
  This command plugin implements a "commands" command.  This command will list
  all of an App::Cmd's commands and their abstracts.
  
  =head1 METHODS
  
  =head2 execute
  
  This is the command's primary method and raison d'etre.  It prints the
  application's usage text (if any) followed by a sorted listing of the
  application's commands and their abstracts.
  
  The commands are printed in sorted groups (created by C<sort_commands>); each
  group is set off by blank lines.
  
  =head2 C<sort_commands>
  
    my @sorted = $cmd->sort_commands(@unsorted);
  
  This method orders the list of commands into sets which it returns as a list of
  arrayrefs.
  
  By default, the first group is for the "help" and "commands" commands, and all
  other commands are in the second group.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_COMMANDS

$fatpacked{"App/Cmd/Command/help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_HELP';
  use strict;
  use warnings;
  
  package App::Cmd::Command::help;
  {
    $App::Cmd::Command::help::VERSION = '0.323';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display a command's help screen
  
  
  sub command_names { qw/help --help -h -?/ }
  
  sub description {
  "This command will either list all of the application commands and their
  abstracts, or display the usage screen for a subcommand with its
  description.\n"
  }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    if (!@$args) {
      my $usage = $self->app->usage->text;
      my $command = $0;
  
      # chars normally used to describe options
      my $opt_descriptor_chars = qr/[\[\]<>\(\)]/;
  
      if ($usage =~ /^(.+?) \s* (?: $opt_descriptor_chars | $ )/x) {
        # try to match subdispatchers too
        $command = $1;
      }
  
      # evil hack ;-)
      bless
        $self->app->{usage} = sub { return "$command help <command>\n" }
        => "Getopt::Long::Descriptive::Usage";
  
      $self->app->execute_command( $self->app->_prepare_command("commands") );
    } else {
      my ($cmd, $opt, $args) = $self->app->prepare_command(@$args);
  
      local $@;
      my $desc = $cmd->description;
      $desc = "\n$desc" if length $desc;
  
      my $ut = join "\n",
        eval { $cmd->usage->leader_text },
        $desc,
        eval { $cmd->usage->option_text };
  
      print "$ut\n";
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::help - display a command's help screen
  
  =head1 VERSION
  
  version 0.323
  
  =head1 DESCRIPTION
  
  This command plugin implements a "help" command.  This command will either list
  all of an App::Cmd's commands and their abstracts, or display the usage screen
  for a subcommand with its description.
  
  =head1 USAGE
  
  The help text is generated from three sources:
  
  =over 4
  
  =item *
  
  The C<usage_desc> method
  
  =item *
  
  The C<description> method
  
  =item *
  
  The C<opt_spec> data structure
  
  =back
  
  The C<usage_desc> method provides the opening usage line, following the
  specification described in L<Getopt::Long::Descriptive>.  In some cases,
  the default C<usage_desc> in L<App::Cmd::Command> may be sufficient and
  you will only need to override it to provide additional command line
  usage information.
  
  The C<opt_spec> data structure is used with L<Getopt::Long::Descriptive>
  to generate the description of the options.
  
  Subcommand classes should override the C<discription> method to provide
  additional information that is prepended before the option descriptions.
  
  For example, consider the following subcommand module:
  
    package YourApp::Command::initialize;
  
    # This is the default from App::Cmd::Command
    sub usage_desc {
      my ($self) = @_;
      my $desc = $self->SUPER::usage_desc; # "%c COMMAND %o"
      return "$desc [DIRECTORY]";
    }
  
    sub description {
      return "The initialize command prepares the application...";
    }
  
    sub opt_spec {
      return (
        [ "skip-refs|R",  "skip reference checks during init", ],
        [ "values|v=s@",  "starting values", { default => [ 0, 1, 3 ] } ],
      );
    }
  
    ...
  
  That module would generate help output like this:
  
    $ yourapp help initialize
    yourapp initialize [-Rv] [long options...] [DIRECTORY]
  
    The initialize command prepares the application...
  
          --help            This usage screen
          -R --skip-refs    skip reference checks during init
          -v --values       starting values
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_HELP

$fatpacked{"App/Cmd/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_COMMAND_VERSION';
  use strict;
  use warnings;
  
  package App::Cmd::Command::version;
  {
    $App::Cmd::Command::version::VERSION = '0.323';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display an app's version
  
  
  sub command_names { qw/version --version/ }
  
  sub version_for_display {
    $_[0]->version_package->VERSION
  }
  
  sub version_package {
    ref($_[0]->app)
  }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    printf "%s (%s) version %s (%s)\n",
      $self->app->arg0, $self->version_package,
      $self->version_for_display, $self->app->full_arg0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Command::version - display an app's version
  
  =head1 VERSION
  
  version 0.323
  
  =head1 DESCRIPTION
  
  This plugin implements the C<version> command, often invoked by its switch-like
  name, C<--version>. On execution it shows the program name, its base class
  with version number, and the full program name.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_COMMAND_VERSION

$fatpacked{"App/Cmd/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_PLUGIN';
  use strict;
  use warnings;
  package App::Cmd::Plugin;
  {
    $App::Cmd::Plugin::VERSION = '0.323';
  }
  # ABSTRACT: a plugin for App::Cmd commands
  
  sub _faux_curried_method {
    my ($class, $name, $arg) = @_;
  
    return sub {
      my $cmd = $App::Cmd::active_cmd;
      $class->$name($cmd, @_);
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Plugin - a plugin for App::Cmd commands
  
  =head1 VERSION
  
  version 0.323
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_PLUGIN

$fatpacked{"App/Cmd/Setup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SETUP';
  use strict;
  use warnings;
  package App::Cmd::Setup;
  {
    $App::Cmd::Setup::VERSION = '0.323';
  }
  # ABSTRACT: helper for setting up App::Cmd classes
  
  
  use App::Cmd ();
  use App::Cmd::Command ();
  use App::Cmd::Plugin ();
  use Carp ();
  use Data::OptList ();
  use String::RewritePrefix ();
  
  # 0.06 is needed for load_optional_class
  use Class::Load 0.06 qw();
  
  use Sub::Exporter -setup => {
    -as     => '_import',
    exports => [ qw(foo) ],
    collectors => [
      -app     => \'_make_app_class',
      -command => \'_make_command_class',
      -plugin  => \'_make_plugin_class',
    ],
  };
  
  sub import {
    goto &_import;
  }
  
  sub _app_base_class { 'App::Cmd' }
  
  sub _make_app_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    $val ||= {};
    Carp::confess "invalid argument to -app setup"
      if grep { $_ ne 'plugins' } keys %$val;
  
    Carp::confess "app setup requested on App::Cmd subclass $into"
      if $into->isa('App::Cmd');
  
    $self->_make_x_isa_y($into, $self->_app_base_class);
  
    if ( ! Class::Load::load_optional_class( $into->_default_command_base ) ) {
      my $base = $self->_command_base_class;
      Sub::Install::install_sub({
        code => sub { $base },
        into => $into,
        as   => '_default_command_base',
      });
    }
  
    # TODO Check this is right. -- kentnl, 2010-12
    #
    #  my $want_plugin_base = $self->_plugin_base_class;
    my $want_plugin_base = 'App::Cmd::Plugin';
  
    my @plugins;
    for my $plugin (@{ $val->{plugins} || [] }) {
      $plugin = String::RewritePrefix->rewrite(
        {
          ''  => 'App::Cmd::Plugin::',
          '=' => ''
        },
        $plugin,
      );
      Class::Load::load_class( $plugin );
      unless( $plugin->isa( $want_plugin_base ) ){
          die "$plugin is not a " . $want_plugin_base;
      }
      push @plugins, $plugin;
    }
  
    Sub::Install::install_sub({
      code => sub { @plugins },
      into => $into,
      as   => '_plugin_plugins',
    });
  
    return 1;
  }
  
  sub _command_base_class { 'App::Cmd::Command' }
  
  sub _make_command_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "command setup requested on App::Cmd::Command subclass $into"
      if $into->isa('App::Cmd::Command');
  
    $self->_make_x_isa_y($into, $self->_command_base_class);
  
    return 1;
  }
  
  sub _make_x_isa_y {
    my ($self, $x, $y) = @_;
  
    no strict 'refs';
    push @{"$x\::ISA"}, $y;
  }
  
  sub _plugin_base_class { 'App::Cmd::Plugin' }
  sub _make_plugin_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "plugin setup requested on App::Cmd::Plugin subclass $into"
      if $into->isa('App::Cmd::Plugin');
  
    Carp::confess "plugin setup requires plugin configuration" unless $val;
  
    $self->_make_x_isa_y($into, $self->_plugin_base_class);
  
    # In this special case, exporting everything by default is the sensible thing
    # to do. -- rjbs, 2008-03-31
    $val->{groups} = [ default => [ -all ] ] unless $val->{groups};
  
    my @exports;
    for my $pair (@{ Data::OptList::mkopt($val->{exports}) }) {
      push @exports, $pair->[0], ($pair->[1] || \'_faux_curried_method');
    }
  
    $val->{exports} = \@exports;
  
    Sub::Exporter::setup_exporter({
      %$val,
      into => $into,
      as   => 'import_from_plugin',
    });
  
    return 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Setup - helper for setting up App::Cmd classes
  
  =head1 VERSION
  
  version 0.323
  
  =head1 OVERVIEW
  
  App::Cmd::Setup is a helper library, used to set up base classes that will be
  used as part of an App::Cmd program.  For the most part you should refer to
  L<the tutorial|App::Cmd::Tutorial> for how you should use this library.
  
  This class is useful in three scenarios:
  
  =over 4
  
  =item when writing your App::Cmd subclass
  
  Instead of writing:
  
    package MyApp;
    use base 'App::Cmd';
  
  ...you can write:
  
    package MyApp;
    use App::Cmd::Setup -app;
  
  The benefits of doing this are mostly minor, and relate to sanity-checking your
  class.  The significant benefit is that this form allows you to specify
  plugins, as in:
  
    package MyApp;
    use App::Cmd::Setup -app => { plugins => [ 'Prompt' ] };
  
  Plugins are described in L<App::Cmd::Tutorial> and L<App::Cmd::Plugin>.
  
  =item when writing abstract base classes for commands
  
  That is: when you write a subclass of L<App::Cmd::Command> that is intended for
  other commands to use as their base class, you should use App::Cmd::Setup.  For
  example, if you want all the commands in MyApp to inherit from MyApp::Command,
  you may want to write that package like this:
  
    package MyApp::Command;
    use App::Cmd::Setup -command;
  
  Do not confuse this with the way you will write specific commands:
  
    package MyApp::Command::mycmd;
    use MyApp -command;
  
  Again, this form mostly performs some validation and setup behind the scenes
  for you.  You can use C<L<base>> if you prefer.
  
  =item when writing App::Cmd plugins
  
  L<App::Cmd::Plugin> is a mechanism that allows an App::Cmd class to inject code
  into all its command classes, providing them with utility routines.
  
  To write a plugin, you must use App::Cmd::Setup.  As seen above, you must also
  use App::Cmd::Setup to set up your App::Cmd subclass if you wish to consume
  plugins.
  
  For more information on writing plugins, see L<App::Cmd::Manual> and
  L<App::Cmd::Plugin>.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SETUP

$fatpacked{"App/Cmd/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SIMPLE';
  use strict;
  use warnings;
  
  package App::Cmd::Simple;
  {
    $App::Cmd::Simple::VERSION = '0.323';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' }
  
  # ABSTRACT: a helper for building one-command App::Cmd applications
  
  use App::Cmd;
  use Sub::Install;
  
  
  # The idea here is that the user will someday replace "Simple" in his ISA with
  # "Command" and then write a standard App::Cmd package.  To make that possible,
  # we produce a behind-the-scenes App::Cmd object when the user says 'use
  # MyApp::Simple' and redirect MyApp::Simple->run to that.
  my $i;
  BEGIN { $i = 0 }
  
  sub import {
    my ($class) = @_;
    return if $class eq __PACKAGE__;
  
    # This signals that something has already set the target up.
    return $class if $class->_cmd_pkg;
  
    my $core_execute = App::Cmd::Command->can('execute');
    my $our_execute  = $class->can('execute');
    Carp::confess(
      "App::Cmd::Simple subclasses must implement ->execute, not ->run"
    ) unless $our_execute and $our_execute != $core_execute;
  
    # I doubt the $i will ever be needed, but let's start paranoid.
    my $generated_name = join('::', $class, '_App_Cmd', $i++);
  
    {
      no strict 'refs';
      *{$generated_name . '::ISA'} = [ 'App::Cmd' ];
    }
  
    Sub::Install::install_sub({
      into => $class,
      as   => '_cmd_pkg',
      code => sub { $generated_name },
    });
  
    Sub::Install::install_sub({
        into => $class,
        as => 'command_names',
        code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_plugins',
      code => sub { $class },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => 'default_command',
      code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_cmd_from_args',
      code => sub {
        my ($self, $args) = @_;
        if (defined(my $command = $args->[0])) {
          my $plugin = $self->plugin_for($command);
          # If help was requested, show the help for the command, not the
          # main help. Because the main help would talk about subcommands,
          # and a "Simple" app has no subcommands.
          if ($plugin and $plugin eq $self->plugin_for("help")) {
            return ($command, [ $self->default_command ]);
          }
          # Any other value for "command" isn't really a command at all --
          # it's the first argument. So call the default command instead.
        }
        return ($self->default_command, $args);
      },
    });
  
    Sub::Install::install_sub({
      into => $class,
      as   => 'run',
      code => sub {
        $generated_name->new({
          no_help_plugin     => 0,
          no_commands_plugin => 1,
        })->run(@_);
      }
    });
  
    return $class;
  }
  
  sub usage_desc {
    return "%c %o"
  }
  
  sub _cmd_pkg { }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Simple - a helper for building one-command App::Cmd applications
  
  =head1 VERSION
  
  version 0.323
  
  =head1 SYNOPSIS
  
  in F<simplecmd>:
  
    use YourApp::Cmd;
    Your::Cmd->run;
  
  in F<YourApp/Cmd.pm>:
  
    package YourApp::Cmd;
    use base qw(App::Cmd::Simple);
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ simplecmd --recheck
  
    All blorts successful.
  
  =head1 SUBCLASSING
  
  When writing a subclass of App::Cmd:Simple, there are only a few methods that
  you might want to implement.  They behave just like the same-named methods in
  App::Cmd.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $cmd->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>) if they are invalid, or it
  may do nothing to allow processing to continue.
  
  =head2 execute
  
    Your::App::Cmd::Simple->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  =head1 WARNINGS
  
  B<This should be considered experimental!>  Although it is probably not going
  to change much, don't build your business model around it yet, okay?
  
  App::Cmd::Simple is not rich in black magic, but it does do some somewhat
  gnarly things to make an App::Cmd::Simple look as much like an
  App::Cmd::Command as possible.  This means that you can't deviate too much from
  the sort of thing shown in the synopsis as you might like.  If you're doing
  something other than writing a fairly simple command, and you want to screw
  around with the App::Cmd-iness of your program, Simple might not be the best
  choice.
  
  B<One specific warning...>  if you are writing a program with the
  App::Cmd::Simple class embedded in it, you B<must> call import on the class.
  That's how things work.  You can just do this:
  
    YourApp::Cmd->import->run;
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SIMPLE

$fatpacked{"App/Cmd/Subdispatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SUBDISPATCH';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch;
  {
    $App::Cmd::Subdispatch::VERSION = '0.323';
  }
  
  use App::Cmd;
  use App::Cmd::Command;
  BEGIN { our @ISA = qw(App::Cmd::Command App::Cmd) } 
  
  # ABSTRACT: an App::Cmd::Command that is also an App::Cmd
  
  
  sub new {
  	my ($inv, $fields, @args) = @_;
  	if (ref $inv) {
  		@{ $inv }{ keys %$fields } = values %$fields;
  		return $inv;
  	} else {
  		$inv->SUPER::new($fields, @args);
  	}
  }
  
  
  sub prepare {
  	my ($class, $app, @args) = @_;
  
  	my $self = $class->new({ app => $app });
  
  	my ($subcommand, $opt, @sub_args) = $self->get_command(@args);
  
    $self->set_global_options($opt);
  
  	if (defined $subcommand) {
      return $self->_prepare_command($subcommand, $opt, @sub_args);
    } else {
      if (@args) {
        return $self->_bad_command(undef, $opt, @sub_args);
      } else {
        return $self->prepare_default_command($opt, @sub_args);
      }
    }
  }
  
  sub _plugin_prepare {
    my ($self, $plugin, @args) = @_;
    return $plugin->prepare($self->choose_parent_app($self->app, $plugin), @args);
  }
  
  
  sub app { $_[0]{app} }
  
  
  sub choose_parent_app {
  	my ( $self, $app, $plugin ) = @_;
  
  	if (
      $plugin->isa("App::Cmd::Command::commands")
      or $plugin->isa("App::Cmd::Command::help")
      or scalar keys %{ $self->global_options }
    ) {
  		return $self;
  	} else {
  		return $app;
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Subdispatch - an App::Cmd::Command that is also an App::Cmd
  
  =head1 VERSION
  
  version 0.323
  
  =head1 METHODS
  
  =head2 new
  
  A hackish new that allows us to have an Command instance before they normally
  exist.
  
  =head2 prepare
  
    my $subcmd = $subdispatch->prepare($app, @args);
  
  An overridden version of L<App::Cmd::Command/prepare> that performs a new
  dispatch cycle.
  
  =head2 app
  
    $subdispatch->app;
  
  This method returns the application that this subdispatch is a command of.
  
  =head2 choose_parent_app
  
    $subcmd->prepare(
      $subdispatch->choose_parent_app($app, $opt, $plugin),
      @$args
    );
  
  A method that chooses whether the parent app or the subdispatch is going to be
  C<< $cmd->app >>.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SUBDISPATCH

$fatpacked{"App/Cmd/Subdispatch/DashedStyle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_SUBDISPATCH_DASHEDSTYLE';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch::DashedStyle;
  {
    $App::Cmd::Subdispatch::DashedStyle::VERSION = '0.323';
  }
  use App::Cmd::Subdispatch;
  BEGIN { our @ISA = 'App::Cmd::Subdispatch' };
  
  # ABSTRACT: "app cmd --subcmd" style subdispatching
  
  
  sub get_command {
  	my ($self, @args) = @_;
  
  	my (undef, $opt, @sub_args)
      = $self->App::Cmd::Command::prepare($self->app, @args);
  
  	if (my $cmd = delete $opt->{subcommand}) {
  		delete $opt->{$cmd}; # useless boolean
  		return ($cmd, $opt, @sub_args);
  	} else {
      return (undef, $opt, @sub_args);
    }
  }
  
  
  sub prepare_default_command {
    my ( $self, $opt, @args ) = @_;
    $self->_prepare_command( "help" );
  }
  
  
  sub opt_spec {
  	my ($self, $app) = @_;
  
  	my $subcommands = $self->_command;
  	my %plugins = map {
  		$_ => [ $_->command_names ],
  	} values %$subcommands;
  
  	foreach my $opt_spec (values %plugins) {
  		$opt_spec = join("|", grep { /^\w/ } @$opt_spec);
  	}
  
  	my @subcommands = map { [ $plugins{$_} =>  $_->abstract ] } keys %plugins;
  
  	return (
  		[ subcommand => hidden => { one_of => \@subcommands } ],
  		$self->global_opt_spec($app),
  		{ getopt_conf => [ 'pass_through' ] },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Subdispatch::DashedStyle - "app cmd --subcmd" style subdispatching
  
  =head1 VERSION
  
  version 0.323
  
  =head1 METHODS
  
  =head2 get_command
  
    my ($subcommand, $opt, $args) = $subdispatch->get_command(@args)
  
  A version of get_command that chooses commands as options in the following
  style:
  
    mytool mycommand --mysubcommand
  
  =head2 opt_spec
  
  A version of C<opt_spec> that calculates the getopt specification from the
  subcommands.
  
  =for Pod::Coverage prepare_default_command
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_SUBDISPATCH_DASHEDSTYLE

$fatpacked{"App/Cmd/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_TESTER';
  use strict;
  use warnings;
  package App::Cmd::Tester;
  {
    $App::Cmd::Tester::VERSION = '0.323';
  }
  
  # ABSTRACT: for capturing the result of running an app
  
  
  use Sub::Exporter::Util qw(curry_method);
  use Sub::Exporter -setup => {
    exports => { test_app => curry_method },
    groups  => { default  => [ qw(test_app) ] },
  };
  
  our $TEST_IN_PROGRESS;
  BEGIN {
    *CORE::GLOBAL::exit = sub {
      return CORE::exit(@_) unless $TEST_IN_PROGRESS;
      App::Cmd::Tester::Exited->throw($_[0]);
    };
  }
  
  
  sub result_class { 'App::Cmd::Tester::Result' }
  
  sub test_app {
    my ($class, $app, $argv) = @_;
  
    local $App::Cmd::_bad = 0;
  
    $app = $app->new unless ref($app) or $app->isa('App::Cmd::Simple');
  
    my $result = $class->_run_with_capture($app, $argv);
  
    my $error = $result->{error};
  
    my $exit_code = defined $error ? ((0+$!)||-1) : 0;
  
    if ($error and eval { $error->isa('App::Cmd::Tester::Exited') }) {
      $exit_code = $$error;
    }
  
    $exit_code =1 if $App::Cmd::_bad && ! $exit_code;
  
    $class->result_class->new({
      app    => $app,
      exit_code => $exit_code,
      %$result,
    });
  }
  
  sub _run_with_capture {
    my ($class, $app, $argv) = @_;
  
    require IO::TieCombine;
    my $hub = IO::TieCombine->new;
  
    my $stdout = tie local *STDOUT, $hub, 'stdout';
    my $stderr = tie local *STDERR, $hub, 'stderr';
  
    my $run_rv;
  
    my $ok = eval {
      local $TEST_IN_PROGRESS = 1;
      local @ARGV = @$argv;
      $run_rv = $app->run;
      1;
    };
  
    my $error = $ok ? undef : $@;
  
    return {
      stdout => $hub->slot_contents('stdout'),
      stderr => $hub->slot_contents('stderr'),
      output => $hub->combined_contents,
      error  => $error,
      run_rv => $run_rv,
    };
  }
  
  {
    package App::Cmd::Tester::Result;
  {
    $App::Cmd::Tester::Result::VERSION = '0.323';
  }
  
    sub new {
      my ($class, $arg) = @_;
      bless $arg => $class;
    }
  
    for my $attr (qw(app stdout stderr output error run_rv exit_code)) {
      Sub::Install::install_sub({
        code => sub { $_[0]->{$attr} },
        as   => $attr,
      });
    }
  }
  
  {
    package App::Cmd::Tester::Exited;
  {
    $App::Cmd::Tester::Exited::VERSION = '0.323';
  }
    sub throw {
      my ($class, $code) = @_;
      $code = 0 unless defined $code;
      my $self = (bless \$code => $class);
      die $self;
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Tester - for capturing the result of running an app
  
  =head1 VERSION
  
  version 0.323
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    is($result->error, undef, 'threw no exceptions');
  
    my $result = test_app(YourApp => [ qw(command --opt value --quiet) ]);
  
    is($result->output, '', 'absolutely no output with --quiet');
  
  =head1 DESCRIPTION
  
  One of the reasons that user-executed programs are so often poorly tested is
  that they are hard to test.  App::Cmd::Tester is one of the tools App-Cmd
  provides to help make it easy to test App::Cmd-based programs.
  
  It provides one routine: test_app.
  
  =head1 METHODS
  
  =head2 test_app
  
  B<Note>: while C<test_app> is a method, it is by default exported as a
  subroutine into the namespace that uses App::Cmd::Tester.  In other words: you
  probably don't need to think about this as a method unless you want to subclass
  App::Cmd::Tester.
  
    my $result = test_app($app_class => \@argv_contents);
  
  This will locally set C<@ARGV> to simulate command line arguments, and will
  then call the C<run> method on the given application class (or application).
  Output to the standard output and standard error filehandles  will be captured.
  
  C<$result> is an App::Cmd::Tester::Result object, which has methods to access
  the following data:
  
    stdout - the output sent to stdout
    stderr - the output sent to stderr
    output - the combined output of stdout and stderr
    error  - the exception thrown by running the application, or undef
    run_rv - the return value of the run method (generally irrelevant)
    exit_code - the numeric exit code that would've been issued (0 is 'okay')
  
  =for Pod::Coverage result_class
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_TESTER

$fatpacked{"App/Cmd/Tester/CaptureExternal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CMD_TESTER_CAPTUREEXTERNAL';
  use strict;
  use warnings;
  package App::Cmd::Tester::CaptureExternal;
  {
    $App::Cmd::Tester::CaptureExternal::VERSION = '0.323';
  }
  
  use parent 'App::Cmd::Tester';
  use Capture::Tiny 0.13 qw/capture/;
  
  # ABSTRACT: Extends App::Cmd::Tester to capture from external subprograms
  
  
  sub _run_with_capture {
    my ($class, $app, $argv) = @_;
  
    my $run_rv;
  
    my ($stdout, $stderr, $ok) = capture {
      eval {
        local $App::Cmd::Tester::TEST_IN_PROGRESS = 1;
        local @ARGV = @$argv;
        $run_rv = $app->run;
        1;
      };
    };
  
    my $error = $ok ? undef : $@;
  
    return {
      stdout => $stdout,
      stderr => $stderr,
      output => $stdout . $stderr,
      error  => $error,
      run_rv => $run_rv,
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::Cmd::Tester::CaptureExternal - Extends App::Cmd::Tester to capture from external subprograms
  
  =head1 VERSION
  
  version 0.323
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester::CaptureExternal;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    ok($result->output, "STDOUT concatenated with STDERR");
  
  =head1 DESCRIPTION
  
  L<App::Cmd::Tester> provides a useful scaffold for testing applications, but it
  is unable to capture output generated from any external subprograms that are
  invoked from the application.
  
  This subclass uses an alternate mechanism for capturing output
  (L<Capture::Tiny>) that does capture from external programs, with one
  major limitation.
  
  It is not possible to capture externally from both STDOUT and STDERR while
  also having appropriately interleaved combined output.  Therefore, the
  C<output> from this subclass simply concatenates the two.
  
  You can still use C<output> for testing if there is any output at all or for
  testing if something appeared in either output stream, but you can't rely on
  the ordering being correct between lines to STDOUT and lines to STDERR.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_CMD_TESTER_CAPTUREEXTERNAL

$fatpacked{"Carp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP';
  package Carp;
  
  { use 5.006; }
  use strict;
  use warnings;
  BEGIN {
      # Very old versions of warnings.pm load Carp.  This can go wrong due
      # to the circular dependency.  If warnings is invoked before Carp,
      # then warnings starts by loading Carp, then Carp (above) tries to
      # invoke warnings, and gets nothing because warnings is in the process
      # of loading and hasn't defined its import method yet.  If we were
      # only turning on warnings ("use warnings" above) this wouldn't be too
      # bad, because Carp would just gets the state of the -w switch and so
      # might not get some warnings that it wanted.  The real problem is
      # that we then want to turn off Unicode warnings, but "no warnings
      # 'utf8'" won't be effective if we're in this circular-dependency
      # situation.  So, if warnings.pm is an affected version, we turn
      # off all warnings ourselves by directly setting ${^WARNING_BITS}.
      # On unaffected versions, we turn off just Unicode warnings, via
      # the proper API.
      if(!defined($warnings::VERSION) || eval($warnings::VERSION) < 1.06) {
  	${^WARNING_BITS} = "";
      } else {
  	"warnings"->unimport("utf8");
      }
  }
  
  sub _fetch_sub { # fetch sub without autovivifying
      my($pack, $sub) = @_;
      $pack .= '::';
      # only works with top-level packages
      return unless exists($::{$pack});
      for ($::{$pack}) {
  	return unless ref \$_ eq 'GLOB' && *$_{HASH} && exists $$_{$sub};
  	for ($$_{$sub}) {
  	    return ref \$_ eq 'GLOB' ? *$_{CODE} : undef
  	}
      }
  }
  
  # UTF8_REGEXP_PROBLEM is a compile-time constant indicating whether Carp
  # must avoid applying a regular expression to an upgraded (is_utf8)
  # string.  There are multiple problems, on different Perl versions,
  # that require this to be avoided.  All versions prior to 5.13.8 will
  # load utf8_heavy.pl for the swash system, even if the regexp doesn't
  # use character classes.  Perl 5.6 and Perls [5.11.2, 5.13.11) exhibit
  # specific problems when Carp is being invoked in the aftermath of a
  # syntax error.
  BEGIN {
      if("$]" < 5.013011) {
  	*UTF8_REGEXP_PROBLEM = sub () { 1 };
      } else {
  	*UTF8_REGEXP_PROBLEM = sub () { 0 };
      }
  }
  
  # is_utf8() is essentially the utf8::is_utf8() function, which indicates
  # whether a string is represented in the upgraded form (using UTF-8
  # internally).  As utf8::is_utf8() is only available from Perl 5.8
  # onwards, extra effort is required here to make it work on Perl 5.6.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'is_utf8')) {
  	*is_utf8 = $sub;
      } else {
  	# black magic for perl 5.6
  	*is_utf8 = sub { unpack("C", "\xaa".$_[0]) != 170 };
      }
  }
  
  # The downgrade() function defined here is to be used for attempts to
  # downgrade where it is acceptable to fail.  It must be called with a
  # second argument that is a true value.
  BEGIN {
      if(defined(my $sub = _fetch_sub utf8 => 'downgrade')) {
  	*downgrade = \&{"utf8::downgrade"};
      } else {
  	*downgrade = sub {
  	    my $r = "";
  	    my $l = length($_[0]);
  	    for(my $i = 0; $i != $l; $i++) {
  		my $o = ord(substr($_[0], $i, 1));
  		return if $o > 255;
  		$r .= chr($o);
  	    }
  	    $_[0] = $r;
  	};
      }
  }
  
  our $VERSION = '1.32';
  
  our $MaxEvalLen = 0;
  our $Verbose    = 0;
  our $CarpLevel  = 0;
  our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
  our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
  our $RefArgFormatter = undef; # allow caller to format reference arguments
  
  require Exporter;
  our @ISA       = ('Exporter');
  our @EXPORT    = qw(confess croak carp);
  our @EXPORT_OK = qw(cluck verbose longmess shortmess);
  our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
  
  # The members of %Internal are packages that are internal to perl.
  # Carp will not report errors from within these packages if it
  # can.  The members of %CarpInternal are internal to Perl's warning
  # system.  Carp will not report errors from within these packages
  # either, and will not report calls *to* these packages for carp and
  # croak.  They replace $CarpLevel, which is deprecated.    The
  # $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
  # text and function arguments should be formatted when printed.
  
  our %CarpInternal;
  our %Internal;
  
  # disable these by default, so they can live w/o require Carp
  $CarpInternal{Carp}++;
  $CarpInternal{warnings}++;
  $Internal{Exporter}++;
  $Internal{'Exporter::Heavy'}++;
  
  # if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
  # then the following method will be called by the Exporter which knows
  # to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
  # 'verbose'.
  
  sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
  
  sub _cgc {
      no strict 'refs';
      return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
      return;
  }
  
  sub longmess {
      local($!, $^E);
      # Icky backwards compatibility wrapper. :-(
      #
      # The story is that the original implementation hard-coded the
      # number of call levels to go back, so calls to longmess were off
      # by one.  Other code began calling longmess and expecting this
      # behaviour, so the replacement has to emulate that behaviour.
      my $cgc = _cgc();
      my $call_pack = $cgc ? $cgc->() : caller();
      if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
          return longmess_heavy(@_);
      }
      else {
          local $CarpLevel = $CarpLevel + 1;
          return longmess_heavy(@_);
      }
  }
  
  our @CARP_NOT;
  
  sub shortmess {
      local($!, $^E);
      my $cgc = _cgc();
  
      # Icky backwards compatibility wrapper. :-(
      local @CARP_NOT = $cgc ? $cgc->() : caller();
      shortmess_heavy(@_);
  }
  
  sub croak   { die shortmess @_ }
  sub confess { die longmess @_ }
  sub carp    { warn shortmess @_ }
  sub cluck   { warn longmess @_ }
  
  BEGIN {
      if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
  	    ("$]" >= 5.012005 && "$]" < 5.013)) {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
      } else {
  	*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
      }
  }
  
  sub caller_info {
      my $i = shift(@_) + 1;
      my %call_info;
      my $cgc = _cgc();
      {
  	# Some things override caller() but forget to implement the
  	# @DB::args part of it, which we need.  We check for this by
  	# pre-populating @DB::args with a sentinel which no-one else
  	# has the address of, so that we can detect whether @DB::args
  	# has been properly populated.  However, on earlier versions
  	# of perl this check tickles a bug in CORE::caller() which
  	# leaks memory.  So we only check on fixed perls.
          @DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
          package DB;
          @call_info{
              qw(pack file line sub has_args wantarray evaltext is_require) }
              = $cgc ? $cgc->($i) : caller($i);
      }
  
      unless ( defined $call_info{file} ) {
          return ();
      }
  
      my $sub_name = Carp::get_subname( \%call_info );
      if ( $call_info{has_args} ) {
          my @args;
          if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1
              && ref $DB::args[0] eq ref \$i
              && $DB::args[0] == \$i ) {
              @DB::args = ();    # Don't let anyone see the address of $i
              local $@;
              my $where = eval {
                  my $func    = $cgc or return '';
                  my $gv      =
                      (_fetch_sub B => 'svref_2object' or return '')
                          ->($func)->GV;
                  my $package = $gv->STASH->NAME;
                  my $subname = $gv->NAME;
                  return unless defined $package && defined $subname;
  
                  # returning CORE::GLOBAL::caller isn't useful for tracing the cause:
                  return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
                  " in &${package}::$subname";
              } || '';
              @args
                  = "** Incomplete caller override detected$where; \@DB::args were not set **";
          }
          else {
              @args = @DB::args;
              my $overflow;
              if ( $MaxArgNums and @args > $MaxArgNums )
              {    # More than we want to show?
                  $#args = $MaxArgNums;
                  $overflow = 1;
              }
  
              @args = map { Carp::format_arg($_) } @args;
  
              if ($overflow) {
                  push @args, '...';
              }
          }
  
          # Push the args onto the subroutine
          $sub_name .= '(' . join( ', ', @args ) . ')';
      }
      $call_info{sub_name} = $sub_name;
      return wantarray() ? %call_info : \%call_info;
  }
  
  # Transform an argument to a function into a string.
  our $in_recurse;
  sub format_arg {
      my $arg = shift;
  
      if ( ref($arg) ) {
           # legitimate, let's not leak it.
          if (!$in_recurse &&
  	    do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg->can('CARP_TRACE') }
              })
          {
              return $arg->CARP_TRACE();
          }
          elsif (!$in_recurse &&
  	       defined($RefArgFormatter) &&
  	       do {
                  local $@;
  	        local $in_recurse = 1;
  		local $SIG{__DIE__} = sub{};
                  eval {$arg = $RefArgFormatter->($arg); 1}
                  })
          {
              return $arg;
          }
          else
          {
  	    my $sub = _fetch_sub(overload => 'StrVal');
  	    return $sub ? &$sub($arg) : "$arg";
          }
      }
      return "undef" if !defined($arg);
      downgrade($arg, 1);
      return $arg if !(UTF8_REGEXP_PROBLEM && is_utf8($arg)) &&
  	    $arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;
      my $suffix = "";
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...";
      }
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $c = substr($arg, $i, 1);
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  	    if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@") {
  		substr $arg, $i, 0, "\\";
  		next;
  	    }
  	    my $o = ord($c);
  	    substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		if $o < 0x20 || $o > 0x7f;
  	}
      } else {
  	$arg =~ s/([\"\\\$\@])/\\$1/g;
  	$arg =~ s/([^ -~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      return "\"".$arg."\"".$suffix;
  }
  
  sub Regexp::CARP_TRACE {
      my $arg = "$_[0]";
      downgrade($arg, 1);
      if(UTF8_REGEXP_PROBLEM && is_utf8($arg)) {
  	for(my $i = length($arg); $i--; ) {
  	    my $o = ord(substr($arg, $i, 1));
  	    my $x = substr($arg, 0, 0);   # work around bug on Perl 5.8.{1,2}
  	    substr $arg, $i, 1, sprintf("\\x{%x}", $o)
  		if $o < 0x20 || $o > 0x7f;
  	}
      } else {
  	$arg =~ s/([^ -~])/sprintf("\\x{%x}",ord($1))/eg;
      }
      downgrade($arg, 1);
      my $suffix = "";
      if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s) {
  	($suffix, $arg) = ($1, $2);
      }
      if ( 2 < $MaxArgLen and $MaxArgLen < length($arg) ) {
          substr ( $arg, $MaxArgLen - 3 ) = "";
  	$suffix = "...".$suffix;
      }
      return "qr($arg)$suffix";
  }
  
  # Takes an inheritance cache and a package and returns
  # an anon hash of known inheritances and anon array of
  # inheritances which consequences have not been figured
  # for.
  sub get_status {
      my $cache = shift;
      my $pkg   = shift;
      $cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
      return @{ $cache->{$pkg} };
  }
  
  # Takes the info from caller() and figures out the name of
  # the sub/require/eval
  sub get_subname {
      my $info = shift;
      if ( defined( $info->{evaltext} ) ) {
          my $eval = $info->{evaltext};
          if ( $info->{is_require} ) {
              return "require $eval";
          }
          else {
              $eval =~ s/([\\\'])/\\$1/g;
              return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
          }
      }
  
      # this can happen on older perls when the sub (or the stash containing it)
      # has been deleted
      if ( !defined( $info->{sub} ) ) {
          return '__ANON__::__ANON__';
      }
  
      return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
  }
  
  # Figures out what call (from the point of view of the caller)
  # the long error backtrace should start at.
  sub long_error_loc {
      my $i;
      my $lvl = $CarpLevel;
      {
          ++$i;
          my $cgc = _cgc();
          my @caller = $cgc ? $cgc->($i) : caller($i);
          my $pkg = $caller[0];
          unless ( defined($pkg) ) {
  
              # This *shouldn't* happen.
              if (%Internal) {
                  local %Internal;
                  $i = long_error_loc();
                  last;
              }
              elsif (defined $caller[2]) {
                  # this can happen when the stash has been deleted
                  # in that case, just assume that it's a reasonable place to
                  # stop (the file and line data will still be intact in any
                  # case) - the only issue is that we can't detect if the
                  # deleted package was internal (so don't do that then)
                  # -doy
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 2;
              }
          }
          redo if $CarpInternal{$pkg};
          redo unless 0 > --$lvl;
          redo if $Internal{$pkg};
      }
      return $i - 1;
  }
  
  sub longmess_heavy {
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = long_error_loc();
      return ret_backtrace( $i, @_ );
  }
  
  # Returns a full stack backtrace starting from where it is
  # told.
  sub ret_backtrace {
      my ( $i, @error ) = @_;
      my $mess;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      $mess = "$err at $i{file} line $i{line}$tid_msg";
      if( defined $. ) {
          local $@ = '';
          local $SIG{__DIE__};
          eval {
              CORE::die;
          };
          if($@ =~ /^Died at .*(, <.*?> line \d+).$/ ) {
              $mess .= $1;
          }
      }
      $mess .= "\.\n";
  
      while ( my %i = caller_info( ++$i ) ) {
          $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
      }
  
      return $mess;
  }
  
  sub ret_summary {
      my ( $i, @error ) = @_;
      my $err = join '', @error;
      $i++;
  
      my $tid_msg = '';
      if ( defined &threads::tid ) {
          my $tid = threads->tid;
          $tid_msg = " thread $tid" if $tid;
      }
  
      my %i = caller_info($i);
      return "$err at $i{file} line $i{line}$tid_msg\.\n";
  }
  
  sub short_error_loc {
      # You have to create your (hash)ref out here, rather than defaulting it
      # inside trusts *on a lexical*, as you want it to persist across calls.
      # (You can default it on $_[2], but that gets messy)
      my $cache = {};
      my $i     = 1;
      my $lvl   = $CarpLevel;
      {
          my $cgc = _cgc();
          my $called = $cgc ? $cgc->($i) : caller($i);
          $i++;
          my $caller = $cgc ? $cgc->($i) : caller($i);
  
          if (!defined($caller)) {
              my @caller = $cgc ? $cgc->($i) : caller($i);
              if (@caller) {
                  # if there's no package but there is other caller info, then
                  # the package has been deleted - treat this as a valid package
                  # in this case
                  redo if defined($called) && $CarpInternal{$called};
                  redo unless 0 > --$lvl;
                  last;
              }
              else {
                  return 0;
              }
          }
          redo if $Internal{$caller};
          redo if $CarpInternal{$caller};
          redo if $CarpInternal{$called};
          redo if trusts( $called, $caller, $cache );
          redo if trusts( $caller, $called, $cache );
          redo unless 0 > --$lvl;
      }
      return $i - 1;
  }
  
  sub shortmess_heavy {
      return longmess_heavy(@_) if $Verbose;
      return @_ if ref( $_[0] );    # don't break references as exceptions
      my $i = short_error_loc();
      if ($i) {
          ret_summary( $i, @_ );
      }
      else {
          longmess_heavy(@_);
      }
  }
  
  # If a string is too long, trims it with ...
  sub str_len_trim {
      my $str = shift;
      my $max = shift || 0;
      if ( 2 < $max and $max < length($str) ) {
          substr( $str, $max - 3 ) = '...';
      }
      return $str;
  }
  
  # Takes two packages and an optional cache.  Says whether the
  # first inherits from the second.
  #
  # Recursive versions of this have to work to avoid certain
  # possible endless loops, and when following long chains of
  # inheritance are less efficient.
  sub trusts {
      my $child  = shift;
      my $parent = shift;
      my $cache  = shift;
      my ( $known, $partial ) = get_status( $cache, $child );
  
      # Figure out consequences until we have an answer
      while ( @$partial and not exists $known->{$parent} ) {
          my $anc = shift @$partial;
          next if exists $known->{$anc};
          $known->{$anc}++;
          my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
          my @found = keys %$anc_knows;
          @$known{@found} = ();
          push @$partial, @$anc_partial;
      }
      return exists $known->{$parent};
  }
  
  # Takes a package and gives a list of those trusted directly
  sub trusts_directly {
      my $class = shift;
      no strict 'refs';
      my $stash = \%{"$class\::"};
      for my $var (qw/ CARP_NOT ISA /) {
          # Don't try using the variable until we know it exists,
          # to avoid polluting the caller's namespace.
          if ( $stash->{$var} && *{$stash->{$var}}{ARRAY} && @{$stash->{$var}} ) {
             return @{$stash->{$var}}
          }
      }
      return;
  }
  
  if(!defined($warnings::VERSION) ||
  	do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
      # Very old versions of warnings.pm import from Carp.  This can go
      # wrong due to the circular dependency.  If Carp is invoked before
      # warnings, then Carp starts by loading warnings, then warnings
      # tries to import from Carp, and gets nothing because Carp is in
      # the process of loading and hasn't defined its import method yet.
      # So we work around that by manually exporting to warnings here.
      no strict "refs";
      *{"warnings::$_"} = \&$_ foreach @EXPORT;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Carp - alternative warn and die for modules
  
  =head1 SYNOPSIS
  
      use Carp;
  
      # warn user (from perspective of caller)
      carp "string trimmed to 80 chars";
  
      # die of errors (from perspective of caller)
      croak "We're outta here!";
  
      # die of errors with stack backtrace
      confess "not implemented";
  
      # cluck, longmess and shortmess not exported by default
      use Carp qw(cluck longmess shortmess);
      cluck "This is how we got here!";
      $long_message   = longmess( "message from cluck() or confess()" );
      $short_message  = shortmess( "message from carp() or croak()" );
  
  =head1 DESCRIPTION
  
  The Carp routines are useful in your own modules because
  they act like C<die()> or C<warn()>, but with a message which is more
  likely to be useful to a user of your module.  In the case of
  C<cluck()> and C<confess()>, that context is a summary of every
  call in the call-stack; C<longmess()> returns the contents of the error
  message.
  
  For a shorter message you can use C<carp()> or C<croak()> which report the
  error as being from where your module was called.  C<shortmess()> returns the
  contents of this error message.  There is no guarantee that that is where the
  error was, but it is a good educated guess.
  
  C<Carp> takes care not to clobber the status variables C<$!> and C<$^E>
  in the course of assembling its error messages.  This means that a
  C<$SIG{__DIE__}> or C<$SIG{__WARN__}> handler can capture the error
  information held in those variables, if it is required to augment the
  error message, and if the code calling C<Carp> left useful values there.
  Of course, C<Carp> can't guarantee the latter.
  
  You can also alter the way the output and logic of C<Carp> works, by
  changing some global variables in the C<Carp> namespace. See the
  section on C<GLOBAL VARIABLES> below.
  
  Here is a more complete description of how C<carp> and C<croak> work.
  What they do is search the call-stack for a function call stack where
  they have not been told that there shouldn't be an error.  If every
  call is marked safe, they give up and give a full stack backtrace
  instead.  In other words they presume that the first likely looking
  potential suspect is guilty.  Their rules for telling whether
  a call shouldn't generate errors work as follows:
  
  =over 4
  
  =item 1.
  
  Any call from a package to itself is safe.
  
  =item 2.
  
  Packages claim that there won't be errors on calls to or from
  packages explicitly marked as safe by inclusion in C<@CARP_NOT>, or
  (if that array is empty) C<@ISA>.  The ability to override what
  @ISA says is new in 5.8.
  
  =item 3.
  
  The trust in item 2 is transitive.  If A trusts B, and B
  trusts C, then A trusts C.  So if you do not override C<@ISA>
  with C<@CARP_NOT>, then this trust relationship is identical to,
  "inherits from".
  
  =item 4.
  
  Any call from an internal Perl module is safe.  (Nothing keeps
  user modules from marking themselves as internal to Perl, but
  this practice is discouraged.)
  
  =item 5.
  
  Any call to Perl's warning system (eg Carp itself) is safe.
  (This rule is what keeps it from reporting the error at the
  point where you call C<carp> or C<croak>.)
  
  =item 6.
  
  C<$Carp::CarpLevel> can be set to skip a fixed number of additional
  call levels.  Using this is not recommended because it is very
  difficult to get it to behave correctly.
  
  =back
  
  =head2 Forcing a Stack Trace
  
  As a debugging aid, you can force Carp to treat a croak as a confess
  and a carp as a cluck across I<all> modules. In other words, force a
  detailed stack trace to be given.  This can be very helpful when trying
  to understand why, or from where, a warning or error is being generated.
  
  This feature is enabled by 'importing' the non-existent symbol
  'verbose'. You would typically enable it by saying
  
      perl -MCarp=verbose script.pl
  
  or by including the string C<-MCarp=verbose> in the PERL5OPT
  environment variable.
  
  Alternately, you can set the global variable C<$Carp::Verbose> to true.
  See the C<GLOBAL VARIABLES> section below.
  
  =head2 Stack Trace formatting
  
  At each stack level, the subroutine's name is displayed along with
  its parameters.  For simple scalars, this is sufficient.  For complex
  data types, such as objects and other references, this can simply
  display C<'HASH(0x1ab36d8)'>.
  
  Carp gives two ways to control this.
  
  =over 4
  
  =item 1.
  
  For objects, a method, C<CARP_TRACE>, will be called, if it exists.  If
  this method doesn't exist, or it recurses into C<Carp>, or it otherwise
  throws an exception, this is skipped, and Carp moves on to the next option,
  otherwise checking stops and the string returned is used.  It is recommended
  that the object's type is part of the string to make debugging easier.
  
  =item 2.
  
  For any type of reference, C<$Carp::RefArgFormatter> is checked (see below).
  This variable is expected to be a code reference, and the current parameter
  is passed in.  If this function doesn't exist (the variable is undef), or
  it recurses into C<Carp>, or it otherwise throws an exception, this is
  skipped, and Carp moves on to the next option, otherwise checking stops
  and the string returned is used.
  
  =item 3.
  
  Otherwise, if neither C<CARP_TRACE> nor C<$Carp::RefArgFormatter> is
  available, stringify the value ignoring any overloading.
  
  =back
  
  =head1 GLOBAL VARIABLES
  
  =head2 $Carp::MaxEvalLen
  
  This variable determines how many characters of a string-eval are to
  be shown in the output. Use a value of C<0> to show all text.
  
  Defaults to C<0>.
  
  =head2 $Carp::MaxArgLen
  
  This variable determines how many characters of each argument to a
  function to print. Use a value of C<0> to show the full length of the
  argument.
  
  Defaults to C<64>.
  
  =head2 $Carp::MaxArgNums
  
  This variable determines how many arguments to each function to show.
  Use a value of C<0> to show all arguments to a function call.
  
  Defaults to C<8>.
  
  =head2 $Carp::Verbose
  
  This variable makes C<carp()> and C<croak()> generate stack backtraces
  just like C<cluck()> and C<confess()>.  This is how C<use Carp 'verbose'>
  is implemented internally.
  
  Defaults to C<0>.
  
  =head2 $Carp::RefArgFormatter
  
  This variable sets a general argument formatter to display references.
  Plain scalars and objects that implement C<CARP_TRACE> will not go through
  this formatter.  Calling C<Carp> from within this function is not supported.
  
  local $Carp::RefArgFormatter = sub {
      require Data::Dumper;
      Data::Dumper::Dump($_[0]); # not necessarily safe
  };
  
  =head2 @CARP_NOT
  
  This variable, I<in your package>, says which packages are I<not> to be
  considered as the location of an error. The C<carp()> and C<cluck()>
  functions will skip over callers when reporting where an error occurred.
  
  NB: This variable must be in the package's symbol table, thus:
  
      # These work
      our @CARP_NOT; # file scope
      use vars qw(@CARP_NOT); # package scope
      @My::Package::CARP_NOT = ... ; # explicit package variable
  
      # These don't work
      sub xyz { ... @CARP_NOT = ... } # w/o declarations above
      my @CARP_NOT; # even at top-level
  
  Example of use:
  
      package My::Carping::Package;
      use Carp;
      our @CARP_NOT;
      sub bar     { .... or _error('Wrong input') }
      sub _error  {
          # temporary control of where'ness, __PACKAGE__ is implicit
          local @CARP_NOT = qw(My::Friendly::Caller);
          carp(@_)
      }
  
  This would make C<Carp> report the error as coming from a caller not
  in C<My::Carping::Package>, nor from C<My::Friendly::Caller>.
  
  Also read the L</DESCRIPTION> section above, about how C<Carp> decides
  where the error is reported from.
  
  Use C<@CARP_NOT>, instead of C<$Carp::CarpLevel>.
  
  Overrides C<Carp>'s use of C<@ISA>.
  
  =head2 %Carp::Internal
  
  This says what packages are internal to Perl.  C<Carp> will never
  report an error as being from a line in a package that is internal to
  Perl.  For example:
  
      $Carp::Internal{ (__PACKAGE__) }++;
      # time passes...
      sub foo { ... or confess("whatever") };
  
  would give a full stack backtrace starting from the first caller
  outside of __PACKAGE__.  (Unless that package was also internal to
  Perl.)
  
  =head2 %Carp::CarpInternal
  
  This says which packages are internal to Perl's warning system.  For
  generating a full stack backtrace this is the same as being internal
  to Perl, the stack backtrace will not start inside packages that are
  listed in C<%Carp::CarpInternal>.  But it is slightly different for
  the summary message generated by C<carp> or C<croak>.  There errors
  will not be reported on any lines that are calling packages in
  C<%Carp::CarpInternal>.
  
  For example C<Carp> itself is listed in C<%Carp::CarpInternal>.
  Therefore the full stack backtrace from C<confess> will not start
  inside of C<Carp>, and the short message from calling C<croak> is
  not placed on the line where C<croak> was called.
  
  =head2 $Carp::CarpLevel
  
  This variable determines how many additional call frames are to be
  skipped that would not otherwise be when reporting where an error
  occurred on a call to one of C<Carp>'s functions.  It is fairly easy
  to count these call frames on calls that generate a full stack
  backtrace.  However it is much harder to do this accounting for calls
  that generate a short message.  Usually people skip too many call
  frames.  If they are lucky they skip enough that C<Carp> goes all of
  the way through the call stack, realizes that something is wrong, and
  then generates a full stack backtrace.  If they are unlucky then the
  error is reported from somewhere misleading very high in the call
  stack.
  
  Therefore it is best to avoid C<$Carp::CarpLevel>.  Instead use
  C<@CARP_NOT>, C<%Carp::Internal> and C<%Carp::CarpInternal>.
  
  Defaults to C<0>.
  
  =head1 BUGS
  
  The Carp routines don't handle exception objects currently.
  If called with a first argument that is a reference, they simply
  call die() or warn(), as appropriate.
  
  Some of the Carp code assumes that Perl's basic character encoding is
  ASCII, and will go wrong on an EBCDIC platform.
  
  =head1 SEE ALSO
  
  L<Carp::Always>,
  L<Carp::Clan>
  
  =head1 AUTHOR
  
  The Carp module first appeared in Larry Wall's perl 5.000 distribution.
  Since then it has been modified by several of the perl 5 porters.
  Andrew Main (Zefram) <zefram@fysh.org> divested Carp into an independent
  distribution.
  
  =head1 COPYRIGHT
  
  Copyright (C) 1994-2013 Larry Wall
  
  Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
CARP

$fatpacked{"Carp/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_HEAVY';
  package Carp::Heavy;
  
  use Carp ();
  
  our $VERSION = '1.32';
  
  my $cv = defined($Carp::VERSION) ? $Carp::VERSION : "undef";
  if($cv ne $VERSION) {
  	die "Version mismatch between Carp $cv ($INC{q(Carp.pm)}) and Carp::Heavy $VERSION ($INC{q(Carp/Heavy.pm)}).  Did you alter \@INC after Carp was loaded?\n";
  }
  
  1;
  
  # Most of the machinery of Carp used to be here.
  # It has been moved in Carp.pm now, but this placeholder remains for
  # the benefit of modules that like to preload Carp::Heavy directly.
  # This must load Carp, because some modules rely on the historical
  # behaviour of Carp::Heavy loading Carp.
CARP_HEAVY

$fatpacked{"Class/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD';
  package Class::Load;
  BEGIN {
    $Class::Load::AUTHORITY = 'cpan:SARTAK';
  }
  # git description: v0.20-8-gc4c6e08
  $Class::Load::VERSION = '0.21';
  use strict;
  use warnings;
  use base 'Exporter';
  use Data::OptList 'mkopt';
  use Module::Implementation 0.04;
  use Module::Runtime 0.012 qw(
      check_module_name
      module_notional_filename
      require_module
      use_module
  );
  use Try::Tiny;
  
  {
      my $loader = Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ],
          symbols         => ['is_class_loaded'],
      );
  
      $loader->();
  }
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded load_first_existing_class/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  sub load_class {
      my $class   = shift;
      my $options = shift;
  
      my ($res, $e) = try_load_class($class, $options);
      return $class if $res;
  
      _croak($e);
  }
  
  sub load_first_existing_class {
      my $classes = Data::OptList::mkopt(\@_)
          or return;
  
      foreach my $class (@{$classes}) {
          check_module_name($class->[0]);
      }
  
      for my $class (@{$classes}) {
          my ($name, $options) = @{$class};
  
          # We need to be careful not to pass an undef $options to this sub,
          # since the XS version will blow up if that happens.
          return $name if is_class_loaded($name, ($options ? $options : ()));
  
          my ($res, $e) = try_load_class($name, $options);
  
          return $name if $res;
  
          my $file = module_notional_filename($name);
  
          next if $e =~ /^Can't locate \Q$file\E in \@INC/;
          next
              if $options
                  && defined $options->{-version}
                  && $e =~ _version_fail_re($name, $options->{-version});
  
          _croak("Couldn't load class ($name) because: $e");
      }
  
      my @list = map {
          $_->[0]
              . ( $_->[1] && defined $_->[1]{-version}
              ? " (version >= $_->[1]{-version})"
              : q{} )
      } @{$classes};
  
      my $err
          .= q{Can't locate }
          . _or_list(@list)
          . " in \@INC (\@INC contains: @INC).";
      _croak($err);
  }
  
  sub _version_fail_re {
      my $name = shift;
      my $vers = shift;
  
      return qr/\Q$name\E version \Q$vers\E required--this is only version/;
  }
  
  sub _nonexistent_fail_re {
      my $name = shift;
  
      my $file = module_notional_filename($name);
      return qr/Can't locate \Q$file\E in \@INC/;
  }
  
  sub _or_list {
      return $_[0] if @_ == 1;
  
      return join ' or ', @_ if @_ ==2;
  
      my $last = pop;
  
      my $list = join ', ', @_;
      $list .= ', or ' . $last;
  
      return $list;
  }
  
  sub load_optional_class {
      my $class   = shift;
      my $options = shift;
  
      check_module_name($class);
  
      my ($res, $e) = try_load_class($class, $options);
      return 1 if $res;
  
      return 0
          if $options
              && defined $options->{-version}
              && $e =~ _version_fail_re($class, $options->{-version});
  
      return 0
          if $e =~ _nonexistent_fail_re($class);
  
      _croak($e);
  }
  
  sub try_load_class {
      my $class   = shift;
      my $options = shift;
  
      check_module_name($class);
  
      local $@;
      undef $ERROR;
  
      if (is_class_loaded($class)) {
          # We need to check this here rather than in is_class_loaded() because
          # we want to return the error message for a failed version check, but
          # is_class_loaded just returns true/false.
          return 1 unless $options && defined $options->{-version};
          return try {
              $class->VERSION($options->{-version});
              1;
          }
          catch {
              _error($_);
          };
      }
  
      my $file = module_notional_filename($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and that's a win-win.
      delete $INC{$file};
      return try {
          local $SIG{__DIE__} = 'DEFAULT';
          if ($options && defined $options->{-version}) {
              use_module($class, $options->{-version});
          }
          else {
              require_module($class);
          }
          1;
      }
      catch {
          _error($_);
      };
  }
  
  sub _error {
      my $e = shift;
  
      $e =~ s/ at .+?Runtime\.pm line [0-9]+\.$//;
      chomp $e;
  
      $ERROR = $e;
      return 0 unless wantarray;
      return 0, $ERROR;
  }
  
  sub _croak {
      require Carp;
      local $Carp::CarpLevel = $Carp::CarpLevel + 2;
      Carp::croak(shift);
  }
  
  1;
  
  # ABSTRACT: a working (require "Class::Name") and more
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load - a working (require "Class::Name") and more
  
  =head1 VERSION
  
  version 0.21
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name, \%options
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  The C<%options> hash currently accepts one key, C<-version>. If you specify a
  version, then this subroutine will call C<< Class::Name->VERSION(
  $options{-version} ) >> internally, which will throw an error if the class's
  version is not equal to or greater than the version you requested.
  
  This method will return the name of the class on success.
  
  =head2 try_load_class Class::Name, \%options -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 is_class_loaded Class::Name, \%options -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  Like C<load_class>, you can pass a C<-version> in C<%options>. If the version
  is not sufficient, then this subroutine will return false.
  
  =head2 load_first_existing_class Class::Name, \%options, ...
  
  This attempts to load the first loadable class in the list of classes
  given. Each class name can be followed by an options hash reference.
  
  If any one of the classes loads and passes the optional version check, that
  class name will be returned. If I<none> of the classes can be loaded (or none
  pass their version check), then an error will be thrown.
  
  If, when attempting to load a class, it fails to load because of a syntax
  error, then an error will be thrown immediately.
  
  =head2 load_optional_class Class::Name, \%options -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1. If you specify a
  version in C<%options>, then the version check must succeed or it will return
  0.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  (e.g.: a syntax error), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, i.e.:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<http://blog.fox.geek.nz/2010/11/searching-design-spec-for-ultimate.html>
  
  This blog post is a good overview of the current state of the existing modules
  for loading other modules in various ways.
  
  =item L<http://blog.fox.geek.nz/2010/11/handling-optional-requirements-with.html>
  
  This blog post describes how to handle optional modules with L<Class::Load>.
  
  =item L<http://d.hatena.ne.jp/tokuhirom/20110202/1296598578>
  
  This Japanese blog post describes why L<DBIx::Skinny> now uses L<Class::Load>
  over its competitors.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =back
  
  =head1 AUTHOR
  
  Shawn M Moore <sartak at bestpractical.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by Shawn M Moore.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CLASS_LOAD

$fatpacked{"Class/Load/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_LOAD_PP';
  package Class::Load::PP;
  BEGIN {
    $Class::Load::PP::AUTHORITY = 'cpan:SARTAK';
  }
  $Class::Load::PP::VERSION = '0.21';
  use strict;
  use warnings;
  use Module::Runtime 'is_module_name';
  use Package::Stash 0.14;
  use Scalar::Util 'blessed', 'reftype';
  use Try::Tiny;
  
  sub is_class_loaded {
      my $class   = shift;
      my $options = shift;
  
      my $loaded = _is_class_loaded($class);
  
      return $loaded if ! $loaded;
      return $loaded unless $options && $options->{-version};
  
      return try {
          $class->VERSION($options->{-version});
          1;
      }
      catch {
          0;
      };
  }
  
  sub _is_class_loaded {
      my $class = shift;
  
      return 0 unless is_module_name($class);
  
      my $stash = Package::Stash->new($class);
  
      if ($stash->has_symbol('$VERSION')) {
          my $version = ${ $stash->get_symbol('$VERSION') };
          if (defined $version) {
              return 1 if ! ref $version;
              # Sometimes $VERSION ends up as a reference to undef (weird)
              return 1 if ref $version && reftype $version eq 'SCALAR' && defined ${$version};
              # a version object
              return 1 if blessed $version;
          }
      }
  
      if ($stash->has_symbol('@ISA')) {
          return 1 if @{ $stash->get_symbol('@ISA') };
      }
  
      # check for any method
      return 1 if $stash->list_all_symbols('CODE');
  
      # fail
      return 0;
  }
  
  1;
  
  =for Pod::Coverage is_class_loaded
  
  =cut
CLASS_LOAD_PP

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;
  use warnings;
  package Data::OptList;
  {
    $Data::OptList::VERSION = '0.109';
  }
  # ABSTRACT: parse and validate simple name/value option pairs
  
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub __is_a {
    my ($got, $expected) = @_;
  
    return List::Util::first { __is_a($got, $_) } @$expected if ref $expected;
  
    return defined (
      exists($test_for{$expected})
      ? $test_for{$expected}->($got)
      : Params::Util::_INSTANCE($got, $expected) ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list) = shift;
  
    my ($moniker, $require_unique, $must_be); # the old positional args
    my $name_test;
  
    if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
      my $arg = $_[0];
      ($moniker, $require_unique, $must_be, $name_test)
        = @$arg{ qw(moniker require_unique must_be name_test) };
    } else {
      ($moniker, $require_unique, $must_be) = @_;
    }
  
    $moniker = 'unnamed' unless defined $moniker;
  
    return [] unless $opt_list;
  
    $name_test ||= sub { ! ref $_[0] };
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
      my $value;
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      if    ($i == $#$opt_list)               { $value = undef;            }
      elsif (not defined $opt_list->[$i+1])   { $value = undef; $i++       }
      elsif ($name_test->($opt_list->[$i+1])) { $value = undef;            }
      else                                    { $value = $opt_list->[++$i] }
  
      if ($must_be and defined $value) {
        unless (__is_a($value, $must_be)) {
          my $ref = ref $value;
          Carp::croak "$ref-ref values are not valid in $moniker opt list";
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.109
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt($input, \%arg);
  
  Valid arguments are:
  
    moniker        - a word used in errors to describe the opt list; encouraged
    require_unique - if true, no name may appear more than once
    must_be        - types to which opt list values are limited (described below)
    name_test      - a coderef used to test whether a value can be a name
                     (described below, but you probably don't want this)
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Positional parameters may be used for compatibility with the old C<mkopt>
  interface:
  
    my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every name followed by a non-name becomes a pair: [ name => ref ]
               every name followed by undef becomes a pair: [ name => undef ]
               otherwise, it becomes [ name => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  By default, a I<name> is any defined non-reference.  The C<name_test> parameter
  can be a code ref that tests whether the argument passed it is a name or not.
  This should be used rarely.  Interactions between C<require_unique> and
  C<name_test> are not yet particularly elegant, as C<require_unique> just tests
  string equality.  B<This may change.>
  
  The C<must_be> parameter is either a scalar or array of scalars; it defines
  what kind(s) of refs may be values.  If an invalid value is found, an exception
  is thrown.  If no value is passed for this argument, any reference is valid.
  If C<must_be> specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
  Params::Util is used to check whether the given value can provide that
  interface.  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2006 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_OPTLIST

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;
  
  use strict;
  use base qw(Exporter);
  use vars qw($VERSION @EXPORT_OK);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '0.4';
  @EXPORT_OK = qw(list_packages);
  
  =pod
  
  =head1 NAME
  
  Devel::InnerPackage - find all the inner packages of a package
  
  =head1 SYNOPSIS
  
      use Foo::Bar;
      use Devel::InnerPackage qw(list_packages);
  
      my @inner_packages = list_packages('Foo::Bar');
  
  
  =head1 DESCRIPTION
  
  
  Given a file like this
  
  
      package Foo::Bar;
  
      sub foo {}
  
  
      package Foo::Bar::Quux;
  
      sub quux {}
  
      package Foo::Bar::Quirka;
  
      sub quirka {}
  
      1;
  
  then
  
      list_packages('Foo::Bar');
  
  will return
  
      Foo::Bar::Quux
      Foo::Bar::Quirka
  
  =head1 METHODS
  
  =head2 list_packages <package name>
  
  Return a list of all inner packages of that package.
  
  =cut
  
  sub list_packages {
              my $pack = shift; $pack .= "::" unless $pack =~ m!::$!;
  
              no strict 'refs';
              my @packs;
              my @stuff = grep !/^(main|)::$/, keys %{$pack};
              for my $cand (grep /::$/, @stuff)
              {
                  $cand =~ s!::$!!;
                  my @children = list_packages($pack.$cand);
      
                  push @packs, "$pack$cand" unless $cand =~ /^::/ ||
                      !__PACKAGE__->_loaded($pack.$cand); # or @children;
                  push @packs, @children;
              }
              return grep {$_ !~ /::(::ISA::CACHE|SUPER)/} @packs;
  }
  
  ### XXX this is an inlining of the Class-Inspector->loaded()
  ### method, but inlined to remove the dependency.
  sub _loaded {
         my ($class, $name) = @_;
  
          no strict 'refs';
  
         # Handle by far the two most common cases
         # This is very fast and handles 99% of cases.
         return 1 if defined ${"${name}::VERSION"};
         return 1 if @{"${name}::ISA"};
  
         # Are there any symbol table entries other than other namespaces
         foreach ( keys %{"${name}::"} ) {
                 next if substr($_, -2, 2) eq '::';
                 return 1 if defined &{"${name}::$_"};
         }
  
         # No functions, and it doesn't have a version, and isn't anything.
         # As an absolute last resort, check for an entry in %INC
         my $filename = join( '/', split /(?:'|::)/, $name ) . '.pm';
         return 1 if defined $INC{$filename};
  
         '';
  }
  
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2005 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =cut 
  
  
  
  
  
  1;
DEVEL_INNERPACKAGE

$fatpacked{"Module/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  {
    $Module::Implementation::VERSION = '0.07';
  }
  BEGIN {
    $Module::Implementation::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $requested = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($requested) = $requested =~ /^(.+)$/;
  
          try {
              require_module($requested);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $requested: $_");
          };
  
          return ( $env_value, $requested );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $try = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($try);
                  $ok = 1;
              }
              catch {
                  $err .= $_ if defined $_;
              };
  
              return ( $possible, $try ) if $ok;
          }
  
          require Carp;
          if ( defined $err && length $err ) {
              Carp::croak(
                  "Could not find a suitable $package implementation: $err");
          }
          else {
              Carp::croak(
                  'Module::Runtime failed to load a module but did not throw a real error. This should never happen. Something is very broken'
              );
          }
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.07
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules.
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
MODULE_IMPLEMENTATION

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;
  
  use strict;
  use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);
  use Module::Pluggable::Object;
  
  use if $] > 5.017, 'deprecate';
  
  # ObQuote:
  # Bob Porter: Looks like you've been missing a lot of work lately. 
  # Peter Gibbons: I wouldn't say I've been missing it, Bob! 
  
  
  $VERSION = '5.1';
  $FORCE_SEARCH_ALL_PATHS = 0;
  
  sub import {
      my $class        = shift;
      my %opts         = @_;
  
      my ($pkg, $file) = caller; 
      # the default name for the method is 'plugins'
      my $sub          = $opts{'sub_name'}  || 'plugins';
      # get our package 
      my ($package)    = $opts{'package'} || $pkg;
      $opts{filename}  = $file;
      $opts{package}   = $package;
      $opts{force_search_all_paths} = $FORCE_SEARCH_ALL_PATHS unless exists $opts{force_search_all_paths};
  
  
      my $finder       = Module::Pluggable::Object->new(%opts);
      my $subroutine   = sub { my $self = shift; return $finder->plugins(@_) };
  
      my $searchsub = sub {
                my $self = shift;
                my ($action,@paths) = @_;
  
                $finder->{'search_path'} = ["${package}::Plugin"] if ($action eq 'add'  and not   $finder->{'search_path'} );
                push @{$finder->{'search_path'}}, @paths      if ($action eq 'add');
                $finder->{'search_path'}       = \@paths      if ($action eq 'new');
                return $finder->{'search_path'};
      };
  
  
      my $onlysub = sub {
          my ($self, $only) = @_;
  
          if (defined $only) {
              $finder->{'only'} = $only;
          };
          
          return $finder->{'only'};
      };
  
      my $exceptsub = sub {
          my ($self, $except) = @_;
  
          if (defined $except) {
              $finder->{'except'} = $except;
          };
          
          return $finder->{'except'};
      };
  
  
      no strict 'refs';
      no warnings qw(redefine prototype);
      
      *{"$package\::$sub"}        = $subroutine;
      *{"$package\::search_path"} = $searchsub;
      *{"$package\::only"}        = $onlysub;
      *{"$package\::except"}      = $exceptsub;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable;
      
  
  and then later ...
  
      use MyClass;
      my $mc = MyClass->new();
      # returns the names of all plugins installed under MyClass::Plugin::*
      my @plugins = $mc->plugins(); 
  
  =head1 EXAMPLE
  
  Why would you want to do this? Say you have something that wants to pass an
  object to a number of different plugins in turn. For example you may 
  want to extract meta-data from every email you get sent and do something
  with it. Plugins make sense here because then you can keep adding new 
  meta data parsers and all the logic and docs for each one will be 
  self contained and new handlers are easy to add without changing the 
  core code. For that, you might do something like ...
  
      package Email::Examiner;
  
      use strict;
      use Email::Simple;
      use Module::Pluggable require => 1;
  
      sub handle_email {
          my $self  = shift;
          my $email = shift;
  
          foreach my $plugin ($self->plugins) {
              $plugin->examine($email);
          }
  
          return 1;
      }
  
  
  
  .. and all the plugins will get a chance in turn to look at it.
  
  This can be trivially extended so that plugins could save the email
  somewhere and then no other plugin should try and do that. 
  Simply have it so that the C<examine> method returns C<1> if 
  it has saved the email somewhere. You might also want to be paranoid
  and check to see if the plugin has an C<examine> method.
  
          foreach my $plugin ($self->plugins) {
              next unless $plugin->can('examine');
              last if     $plugin->examine($email);
          }
  
  
  And so on. The sky's the limit.
  
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  =head1 ADVANCED USAGE
  
  Alternatively, if you don't want to use 'plugins' as the method ...
  
      package MyClass;
      use Module::Pluggable sub_name => 'foo';
  
  
  and then later ...
  
      my @plugins = $mc->foo();
  
  
  Or if you want to look in another namespace
  
      package MyClass;
      use Module::Pluggable search_path => ['Acme::MyClass::Plugin', 'MyClass::Extend'];
  
  or directory 
  
      use Module::Pluggable search_dirs => ['mylibs/Foo'];
  
  
  Or if you want to instantiate each plugin rather than just return the name
  
      package MyClass;
      use Module::Pluggable instantiate => 'new';
  
  and then
  
      # whatever is passed to 'plugins' will be passed 
      # to 'new' for each plugin 
      my @plugins = $mc->plugins(@options); 
  
  
  alternatively you can just require the module without instantiating it
  
      package MyClass;
      use Module::Pluggable require => 1;
  
  since requiring automatically searches inner packages, which may not be desirable, you can turn this off
  
  
      package MyClass;
      use Module::Pluggable require => 1, inner => 0;
  
  
  You can limit the plugins loaded using the except option, either as a string,
  array ref or regex
  
      package MyClass;
      use Module::Pluggable except => 'MyClass::Plugin::Foo';
  
  or
  
      package MyClass;
      use Module::Pluggable except => ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];
  
  or
  
      package MyClass;
      use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
  
  
  and similarly for only which will only load plugins which match.
  
  Remember you can use the module more than once
  
      package MyClass;
      use Module::Pluggable search_path => 'MyClass::Filters' sub_name => 'filters';
      use Module::Pluggable search_path => 'MyClass::Plugins' sub_name => 'plugins';
  
  and then later ...
  
      my @filters = $self->filters;
      my @plugins = $self->plugins;
      
  =head1 PLUGIN SEARCHING
  
  Every time you call 'plugins' the whole search path is walked again. This allows 
  for dynamically loading plugins even at run time. However this can get expensive 
  and so if you don't expect to want to add new plugins at run time you could do
  
  
    package Foo;
    use strict;
    use Module::Pluggable sub_name => '_plugins';
  
    our @PLUGINS;
    sub plugins { @PLUGINS ||= shift->_plugins }
    1;
  
  =head1 INNER PACKAGES
  
  If you have, for example, a file B<lib/Something/Plugin/Foo.pm> that
  contains package definitions for both C<Something::Plugin::Foo> and 
  C<Something::Plugin::Bar> then as long as you either have either 
  the B<require> or B<instantiate> option set then we'll also find 
  C<Something::Plugin::Bar>. Nifty!
  
  =head1 OPTIONS
  
  You can pass a hash of options when importing this module.
  
  The options can be ...
  
  =head2 sub_name
  
  The name of the subroutine to create in your namespace. 
  
  By default this is 'plugins'
  
  =head2 search_path
  
  An array ref of namespaces to look in. 
  
  =head2 search_dirs 
  
  An array ref of directories to look in before @INC.
  
  =head2 instantiate
  
  Call this method on the class. In general this will probably be 'new'
  but it can be whatever you want. Whatever arguments are passed to 'plugins' 
  will be passed to the method.
  
  The default is 'undef' i.e just return the class name.
  
  =head2 require
  
  Just require the class, don't instantiate (overrides 'instantiate');
  
  =head2 inner
  
  If set to 0 will B<not> search inner packages. 
  If set to 1 will override C<require>.
  
  =head2 only
  
  Takes a string, array ref or regex describing the names of the only plugins to 
  return. Whilst this may seem perverse ... well, it is. But it also 
  makes sense. Trust me.
  
  =head2 except
  
  Similar to C<only> it takes a description of plugins to exclude 
  from returning. This is slightly less perverse.
  
  =head2 package
  
  This is for use by extension modules which build on C<Module::Pluggable>:
  passing a C<package> option allows you to place the plugin method in a
  different package other than your own.
  
  =head2 file_regex
  
  By default C<Module::Pluggable> only looks for I<.pm> files.
  
  By supplying a new C<file_regex> then you can change this behaviour e.g
  
      file_regex => qr/\.plugin$/
  
  =head2 include_editor_junk
  
  By default C<Module::Pluggable> ignores files that look like they were
  left behind by editors. Currently this means files ending in F<~> (~),
  the extensions F<.swp> or F<.swo>, or files beginning with F<.#>.
  
  Setting C<include_editor_junk> changes C<Module::Pluggable> so it does
  not ignore any files it finds.
  
  =head2 follow_symlinks
  
  Whether, when searching directories, to follow symlinks.
  
  Defaults to 1 i.e do follow symlinks.
  
  =head2 min_depth, max_depth
  
  This will allow you to set what 'depth' of plugin will be allowed.
  
  So, for example, C<MyClass::Plugin::Foo> will have a depth of 3 and 
  C<MyClass::Plugin::Foo::Bar> will have a depth of 4 so to only get the former 
  (i.e C<MyClass::Plugin::Foo>) do
  
          package MyClass;
          use Module::Pluggable max_depth => 3;
          
  and to only get the latter (i.e C<MyClass::Plugin::Foo::Bar>)
  
          package MyClass;
          use Module::Pluggable min_depth => 4;
  
  
  =head1 TRIGGERS
  
  Various triggers can also be passed in to the options.
  
  If any of these triggers return 0 then the plugin will not be returned.
  
  =head2 before_require <plugin>
  
  Gets passed the plugin name. 
  
  If 0 is returned then this plugin will not be required either.
  
  =head2 on_require_error <plugin> <err>
  
  Gets called when there's an error on requiring the plugin.
  
  Gets passed the plugin name and the error. 
  
  The default on_require_error handler is to C<carp> the error and return 0.
  
  =head2 on_instantiate_error <plugin> <err>
  
  Gets called when there's an error on instantiating the plugin.
  
  Gets passed the plugin name and the error. 
  
  The default on_instantiate_error handler is to C<carp> the error and return 0.
  
  =head2 after_require <plugin>
  
  Gets passed the plugin name. 
  
  If 0 is returned then this plugin will be required but not returned as a plugin.
  
  =head1 METHODs
  
  =head2 search_path
  
  The method C<search_path> is exported into you namespace as well. 
  You can call that at any time to change or replace the 
  search_path.
  
      $self->search_path( add => "New::Path" ); # add
      $self->search_path( new => "New::Path" ); # replace
  
  =head1 BEHAVIOUR UNDER TEST ENVIRONMENT
  
  In order to make testing reliable we exclude anything not from blib if blib.pm is 
  in %INC. 
  
  However if the module being tested used another module that itself used C<Module::Pluggable> 
  then the second module would fail. This was fixed by checking to see if the caller 
  had (^|/)blib/ in their filename.
  
  There's an argument that this is the wrong behaviour and that modules should explicitly
  trigger this behaviour but that particular code has been around for 7 years now and I'm 
  reluctant to change the default behaviour.
  
  You can now (as of version 4.1) force Module::Pluggable to look outside blib in a test environment by doing either
  
          require Module::Pluggable;
          $Module::Pluggable::FORCE_SEARCH_ALL_PATHS = 1;
          import Module::Pluggable;
  
  or
  
          use Module::Pluggable force_search_all_paths => 1;
  
  =head1 @INC hooks and App::FatPacker
  
  If a module's @INC has a hook and that hook is an object which has a C<files()> method then we will
  try and require those files too. See C<t/26inc_hook.t> for an example.
  
  This has allowed L<App::FatPacker> (as of version 0.10.0) to provide support for Module::Pluggable.
  
  This should also, theoretically, allow someone to modify PAR to do the same thing.
  
  =head1 FUTURE PLANS
  
  This does everything I need and I can't really think of any other 
  features I want to add. Famous last words of course (not least 
  because we're up to version 5.0 at the time of writing).
  
  However suggestions (and patches) are always welcome.
  
  =head1 DEVELOPMENT
  
  The master repo for this module is at
  
  https://github.com/simonwistow/Module-Pluggable
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<File::Find>, L<File::Basename>, L<Class::Factory::Util>, L<Module::Pluggable::Ordered>
  
  =cut 
  
  
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;
  
  use strict;
  use File::Find ();
  use File::Basename;
  use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);
  use Carp qw(croak carp confess);
  use Devel::InnerPackage;
  use vars qw($VERSION);
  
  use if $] > 5.017, 'deprecate';
  
  $VERSION = '5.1';
  
  
  sub new {
      my $class = shift;
      my %opts  = @_;
  
      return bless \%opts, $class;
  
  }
  
  ### Eugggh, this code smells 
  ### This is what happens when you keep adding patches
  ### *sigh*
  
  
  sub plugins {
      my $self = shift;
      my @args = @_;
  
      # override 'require'
      $self->{'require'} = 1 if $self->{'inner'};
  
      my $filename   = $self->{'filename'};
      my $pkg        = $self->{'package'};
  
      # Get the exception params instantiated
      $self->_setup_exceptions;
  
      # automatically turn a scalar search path or namespace into a arrayref
      for (qw(search_path search_dirs)) {
          $self->{$_} = [ $self->{$_} ] if exists $self->{$_} && !ref($self->{$_});
      }
  
      # default search path is '<Module>::<Name>::Plugin'
      $self->{'search_path'} ||= ["${pkg}::Plugin"]; 
  
      # default error handler
      $self->{'on_require_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't require $plugin : $err"; return 0 };
      $self->{'on_instantiate_error'} ||= sub { my ($plugin, $err) = @_; carp "Couldn't instantiate $plugin: $err"; return 0 };
  
      # default whether to follow symlinks
      $self->{'follow_symlinks'} = 1 unless exists $self->{'follow_symlinks'};
  
      # check to see if we're running under test
      my @SEARCHDIR = exists $INC{"blib.pm"} && defined $filename && $filename =~ m!(^|/)blib/! && !$self->{'force_search_all_paths'} ? grep {/blib/} @INC : @INC;
  
      # add any search_dir params
      unshift @SEARCHDIR, @{$self->{'search_dirs'}} if defined $self->{'search_dirs'};
  
      # set our @INC up to include and prefer our search_dirs if necessary
      my @tmp = @INC;
      unshift @tmp, @{$self->{'search_dirs'} || []};
      local @INC = @tmp if defined $self->{'search_dirs'};
  
      my @plugins = $self->search_directories(@SEARCHDIR);
      push(@plugins, $self->handle_inc_hooks($_, @SEARCHDIR)) for @{$self->{'search_path'}};
      push(@plugins, $self->handle_innerpackages($_)) for @{$self->{'search_path'}};
      
      # return blank unless we've found anything
      return () unless @plugins;
  
      # remove duplicates
      # probably not necessary but hey ho
      my %plugins;
      for(@plugins) {
          next unless $self->_is_legit($_);
          $plugins{$_} = 1;
      }
  
      # are we instantiating or requiring?
      if (defined $self->{'instantiate'}) {
          my $method = $self->{'instantiate'};
          my @objs   = ();
          foreach my $package (sort keys %plugins) {
              next unless $package->can($method);
              my $obj = eval { $package->$method(@_) };
              $self->{'on_instantiate_error'}->($package, $@) if $@;
              push @objs, $obj if $obj;           
          }
          return @objs;
      } else { 
          # no? just return the names
          my @objs= sort keys %plugins;
          return @objs;
      }
  }
  
  sub _setup_exceptions {
      my $self = shift;
  
      my %only;   
      my %except; 
      my $only;
      my $except;
  
      if (defined $self->{'only'}) {
          if (ref($self->{'only'}) eq 'ARRAY') {
              %only   = map { $_ => 1 } @{$self->{'only'}};
          } elsif (ref($self->{'only'}) eq 'Regexp') {
              $only = $self->{'only'}
          } elsif (ref($self->{'only'}) eq '') {
              $only{$self->{'only'}} = 1;
          }
      }
          
  
      if (defined $self->{'except'}) {
          if (ref($self->{'except'}) eq 'ARRAY') {
              %except   = map { $_ => 1 } @{$self->{'except'}};
          } elsif (ref($self->{'except'}) eq 'Regexp') {
              $except = $self->{'except'}
          } elsif (ref($self->{'except'}) eq '') {
              $except{$self->{'except'}} = 1;
          }
      }
      $self->{_exceptions}->{only_hash}   = \%only;
      $self->{_exceptions}->{only}        = $only;
      $self->{_exceptions}->{except_hash} = \%except;
      $self->{_exceptions}->{except}      = $except;
          
  }
  
  sub _is_legit {
      my $self   = shift;
      my $plugin = shift;
      my %only   = %{$self->{_exceptions}->{only_hash}||{}};
      my %except = %{$self->{_exceptions}->{except_hash}||{}};
      my $only   = $self->{_exceptions}->{only};
      my $except = $self->{_exceptions}->{except};
      my $depth  = () = split '::', $plugin, -1;
  
      return 0 if     (keys %only   && !$only{$plugin}     );
      return 0 unless (!defined $only || $plugin =~ m!$only!     );
  
      return 0 if     (keys %except &&  $except{$plugin}   );
      return 0 if     (defined $except &&  $plugin =~ m!$except! );
      
      return 0 if     defined $self->{max_depth} && $depth>$self->{max_depth};
      return 0 if     defined $self->{min_depth} && $depth<$self->{min_depth};
  
      return 1;
  }
  
  sub search_directories {
      my $self      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      # go through our @INC
      foreach my $dir (@SEARCHDIR) {
          push @plugins, $self->search_paths($dir);
      }
      return @plugins;
  }
  
  
  sub search_paths {
      my $self = shift;
      my $dir  = shift;
      my @plugins;
  
      my $file_regex = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # and each directory in our search path
      foreach my $searchpath (@{$self->{'search_path'}}) {
          # create the search directory in a cross platform goodness way
          my $sp = catdir($dir, (split /::/, $searchpath));
  
          # if it doesn't exist or it's not a dir then skip it
          next unless ( -e $sp && -d _ ); # Use the cached stat the second time
  
          my @files = $self->find_files($sp);
  
          # foreach one we've found 
          foreach my $file (@files) {
              # untaint the file; accept .pm only
              next unless ($file) = ($file =~ /(.*$file_regex)$/); 
              # parse the file to get the name
              my ($name, $directory, $suffix) = fileparse($file, $file_regex);
  
              next if (!$self->{include_editor_junk} && $self->_is_editor_junk($name));
  
              $directory = abs2rel($directory, $sp);
  
              # If we have a mixed-case package name, assume case has been preserved
              # correctly.  Otherwise, root through the file to locate the case-preserved
              # version of the package name.
              my @pkg_dirs = ();
              if ( $name eq lc($name) || $name eq uc($name) ) {
                  my $pkg_file = catfile($sp, $directory, "$name$suffix");
                  open PKGFILE, "<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";
                  my $in_pod = 0;
                  while ( my $line = <PKGFILE> ) {
                      $in_pod = 1 if $line =~ m/^=\w/;
                      $in_pod = 0 if $line =~ /^=cut/;
                      next if ($in_pod || $line =~ /^=cut/);  # skip pod text
                      next if $line =~ /^\s*#/;               # and comments
                      if ( $line =~ m/^\s*package\s+(.*::)?($name)\s*;/i ) {
                          @pkg_dirs = split /::/, $1 if defined $1;;
                          $name = $2;
                          last;
                      }
                  }
                  close PKGFILE;
              }
  
              # then create the class name in a cross platform way
              $directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);       # remove volume
              my @dirs = ();
              if ($directory) {
                  ($directory) = ($directory =~ /(.*)/);
                  @dirs = grep(length($_), splitdir($directory)) 
                      unless $directory eq curdir();
                  for my $d (reverse @dirs) {
                      my $pkg_dir = pop @pkg_dirs; 
                      last unless defined $pkg_dir;
                      $d =~ s/\Q$pkg_dir\E/$pkg_dir/i;  # Correct case
                  }
              } else {
                  $directory = "";
              }
              my $plugin = join '::', $searchpath, @dirs, $name;
  
              next unless $plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;
  
              $self->handle_finding_plugin($plugin, \@plugins)
          }
  
          # now add stuff that may have been in package
          # NOTE we should probably use all the stuff we've been given already
          # but then we can't unload it :(
          push @plugins, $self->handle_innerpackages($searchpath);
      } # foreach $searchpath
  
      return @plugins;
  }
  
  sub _is_editor_junk {
      my $self = shift;
      my $name = shift;
  
      # Emacs (and other Unix-y editors) leave temp files ending in a
      # tilde as a backup.
      return 1 if $name =~ /~$/;
      # Emacs makes these files while a buffer is edited but not yet
      # saved.
      return 1 if $name =~ /^\.#/;
      # Vim can leave these files behind if it crashes.
      return 1 if $name =~ /\.sw[po]$/;
  
      return 0;
  }
  
  sub handle_finding_plugin {
      my $self    = shift;
      my $plugin  = shift;
      my $plugins = shift;
      my $no_req  = shift || 0;
      
      return unless $self->_is_legit($plugin);
      unless (defined $self->{'instantiate'} || $self->{'require'}) {
          push @$plugins, $plugin;
          return;
      } 
  
      $self->{before_require}->($plugin) || return if defined $self->{before_require};
      unless ($no_req) {
          my $tmp = $@;
          my $res = eval { $self->_require($plugin) };
          my $err = $@;
          $@      = $tmp;
          if ($err) {
              if (defined $self->{on_require_error}) {
                  $self->{on_require_error}->($plugin, $err) || return; 
              } else {
                  return;
              }
          }
      }
      $self->{after_require}->($plugin) || return if defined $self->{after_require};
      push @$plugins, $plugin;
  }
  
  sub find_files {
      my $self         = shift;
      my $search_path  = shift;
      my $file_regex   = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # find all the .pm files in it
      # this isn't perfect and won't find multiple plugins per file
      #my $cwd = Cwd::getcwd;
      my @files = ();
      { # for the benefit of perl 5.6.1's Find, localize topic
          local $_;
          File::Find::find( { no_chdir => 1, 
                              follow   => $self->{'follow_symlinks'}, 
                              wanted   => sub { 
                               # Inlined from File::Find::Rule C< name => '*.pm' >
                               return unless $File::Find::name =~ /$file_regex/;
                               (my $path = $File::Find::name) =~ s#^\\./##;
                               push @files, $path;
                             }
                        }, $search_path );
      }
      #chdir $cwd;
      return @files;
  
  }
  
  sub handle_inc_hooks {
      my $self      = shift;
      my $path      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      for my $dir ( @SEARCHDIR ) {
          next unless ref $dir && eval { $dir->can( 'files' ) };
  
          foreach my $plugin ( $dir->files ) {
              $plugin =~ s/\.pm$//;
              $plugin =~ s{/}{::}g;
              next unless $plugin =~ m!^${path}::!;
              $self->handle_finding_plugin( $plugin, \@plugins );
          }
      }
      return @plugins;
  }
  
  sub handle_innerpackages {
      my $self = shift;
      return () if (exists $self->{inner} && !$self->{inner});
  
      my $path = shift;
      my @plugins;
  
      foreach my $plugin (Devel::InnerPackage::list_packages($path)) {
          $self->handle_finding_plugin($plugin, \@plugins, 1);
      }
      return @plugins;
  
  }
  
  
  sub _require {
      my $self   = shift;
      my $pack   = shift;
      eval "CORE::require $pack";
      die ($@) if $@;
      return 1;
  }
  
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable::Object - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable::Object;
      
      my $finder = Module::Pluggable::Object->new(%opts);
      print "My plugins are: ".join(", ", $finder->plugins)."\n";
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  This object is wrapped by C<Module::Pluggable>. If you want to do something
  odd or add non-general special features you're probably best to wrap this
  and produce your own subclass.
  
  =head1 OPTIONS
  
  See the C<Module::Pluggable> docs.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<Module::Pluggable>
  
  =cut 
  
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"String/RewritePrefix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_REWRITEPREFIX';
  use strict;
  use warnings;
  package String::RewritePrefix;
  {
    $String::RewritePrefix::VERSION = '0.007';
  }
  use Carp ();
  # ABSTRACT: rewrite strings based on a set of known prefixes
  
  # 0.972 allows \'method_name' form -- rjbs, 2010-10-25
  use Sub::Exporter 0.972 -setup => {
    exports => [ rewrite => \'_new_rewriter' ],
  };
  
  
  sub rewrite {
    my ($self, $arg, @rest) = @_;
    return $self->_new_rewriter(rewrite => { prefixes => $arg })->(@rest);
  }
  
  sub _new_rewriter {
    my ($self, $name, $arg) = @_;
    my $rewrites = $arg->{prefixes} || {};
  
    my @rewrites;
    for my $prefix (sort { length $b <=> length $a } keys %$rewrites) {
      push @rewrites, ($prefix, $rewrites->{$prefix});
    }
  
    return sub {
      my @result;
  
      Carp::cluck("string rewriter invoked in void context")
        unless defined wantarray;
  
      Carp::croak("attempt to rewrite multiple strings outside of list context")
        if @_ > 1 and ! wantarray;
  
      STRING: for my $str (@_) {
        for (my $i = 0; $i < @rewrites; $i += 2) {
          if (index($str, $rewrites[$i]) == 0) {
            if (ref $rewrites[$i+1]) {
              my $rest = substr $str, length($rewrites[$i]);
              my $str  = $rewrites[ $i+1 ]->($rest);
              push @result, (defined $str ? $str : '') . $rest;
            } else {
              push @result, $rewrites[$i+1] . substr $str, length($rewrites[$i]);
            }
            next STRING;
          }
        }
  
        push @result, $str;
      }
      
      return wantarray ? @result : $result[0];
    };
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  String::RewritePrefix - rewrite strings based on a set of known prefixes
  
  =head1 VERSION
  
  version 0.007
  
  =head1 SYNOPSIS
  
    use String::RewritePrefix;
    my @to_load = String::RewritePrefix->rewrite(
      { '' => 'MyApp::', '+' => '' },
      qw(Plugin Mixin Addon +Corporate::Thinger),
    );
  
    # now you have:
    qw(MyApp::Plugin MyApp::Mixin MyApp::Addon Corporate::Thinger)
  
  You can also import a rewrite routine:
  
    use String::RewritePrefix rewrite => {
      -as => 'rewrite_dt_prefix',
      prefixes => { '' => 'MyApp::', '+' => '' },
    };
  
    my @to_load = rewrite_dt_prefix( qw(Plugin Mixin Addon +Corporate::Thinger));
  
    # now you have:
    qw(MyApp::Plugin MyApp::Mixin MyApp::Addon Corporate::Thinger)
  
  =head1 METHODS
  
  =head2 rewrite
  
    String::RewritePrefix->rewrite(\%prefix, @strings);
  
  This rewrites all the given strings using the rules in C<%prefix>.  Its keys
  are known prefixes for which its values will be substituted.  This is performed
  in longest-first order, and only one prefix will be rewritten.
  
  If the prefix value is a coderef, it will be executed with the remaining string
  as its only argument.  The return value will be used as the prefix.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
STRING_REWRITEPREFIX

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  {
    $Sub::Exporter::VERSION = '0.987';
  }
  # ABSTRACT: a sophisticated exporter for custom-built routines
  
  use Carp ();
  use Data::OptList 0.100 ();
  use Params::Util 0.14 (); # _CODELIKE
  use Sub::Install 0.92 ();
  
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  
  
  "jn8:32"; # <-- magic true value
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.987
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The package with the generator for that would look something like this:
  
    package Data::Analyze;
    use Sub::Exporter -setup => {
      exports => [
        analyze => \&build_analyzer,
      ],
    };
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertently imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function3);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the importer to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as an exercise for the
  reader.
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and helped me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  package Sub::Exporter::Util;
  {
    $Sub::Exporter::Util::VERSION = '0.987';
  }
  # ABSTRACT: utilities to make Sub::Exporter easier
  
  use Data::OptList ();
  use Params::Util ();
  
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.987
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilities may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain(
        new => gather_data => analyze => [ detail => 100 ] => 'results'
      ),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Spliner->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multiple exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2007 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;
  use warnings;
  package Sub::Install;
  {
    $Sub::Install::VERSION = '0.927';
  }
  # ABSTRACT: install subroutines into packages easily
  
  use Carp;
  use Scalar::Util ();
  
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine \S+ redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ \S+\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  
  sub exporter {
    my ($arg) = @_;
  
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.927
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unsightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 EXTRA CREDITS
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 AUTHOR
  
  Ricardo SIGNES <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2005 by Ricardo SIGNES.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_INSTALL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  $Try::Tiny::VERSION = '0.19';
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.19
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"instaenv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV';
  package instaenv;
  # ABSTRACT: instaenv quick, dirty, and objectionable.
  $instaenv::VERSION = '0.1';
  
  use App::Cmd::Setup -app;
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv - instaenv quick, dirty, and objectionable.
  
  =head1 VERSION
  
  version 0.1
  
  =head1 SYNOPSIS
  
      # Installing
      $ instaenv i plenv
      $ instaenv i pyenv
      $ instaenv i rbenv
      $ instaenv i --all
  
      # Upgrading
      $ instaenv u plenv
      $ instaenv u rbenv
      $ instaenv u pyenv
  
  =head1 DESCRIPTION
  
  Installing environments made ez-pz.
  
  =head1 USAGE
  
  Add
  L<instaenv|https://github.com/battlemidget/instaenv/blob/master/instaenv>
  script to your B<PATH> and make executable.
  
  Everything is included so no deps other than a perl interpreter.
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV

$fatpacked{"instaenv/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV_BASE';
  package instaenv::Base;
  $instaenv::Base::VERSION = '0.1';
  # ABSTRACT: Base env class
  use Path::Tiny;
  
  use Moo;
  use namespace::clean;
  
  
  has 'install_path' => (is => 'ro');
  
  
  has 'plugin' => (is => 'ro');
  
  
  has 'interpreter' => (is => 'ro');
  
  
  has 'shim_path' => (is => 'ro');
  
  
  has 'init_str' => (is => 'ro');
  
  
  has 'env_name' => (is => 'ro');
  
  
  BEGIN {
      my $self = shift;
      path('~/.instaenv')->mkpath unless path('~/.instaenv')->exists;
  }
  
  
  sub install_env {
      my $self = shift;
      system(
          sprintf(
              "git clone %s %s > /dev/null 2>&1",
              $self->install_path->{repo},
              $self->install_path->{dst}->absolute
          )
      ) unless $self->install_path->{dst}->exists;
      system(
          sprintf(
              "git clone %s %s > /dev/null 2>&1",
              $self->plugin->{repo},
              $self->plugin->{dst}->absolute
          )
      ) unless $self->plugin->{dst}->exists;
      $self->cleanup;
  }
  
  
  sub upgrade_env {
      my $self = shift;
      system(
          sprintf("cd %s && git pull > /dev/null 2>&1",
              $self->install_path->{dst}->absolute)
      );
      system(
          sprintf("cd %s && git pull > /dev/null 2>&1",
              $self->plugin->{dst}->absolute)
      );
      printf("Environment: %s, updated.\n", $self->env_name);
  }
  
  
  sub cleanup {
      my $self = shift;
      printf(
          "Environment %s installed. Add the "
            . "following to either ~/.profile or ~/.zshrc\n\n",
          $self->env_name
      );
      printf("%s\n",   $self->shim_path);
      printf("%s\n\n", $self->init_str);
      print("Then run the following: exec \$SHELL -l\n");
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv::Base - Base env class
  
  =head1 VERSION
  
  version 0.1
  
  =head1 ATTRIBUTES
  
  =head2 install_path
  
  attribute for providing the installation requirements.
  
  At minimum this would return
  
      { repo => 'git://', dst => 'local path' }
  
  =head2 plugin
  
  attribute for describing the plugin installed
  
  At minimum this would return
  
      { repo => 'git://', dst => 'local path' }
  
  =head2 interpreter
  
  interpreter mapping
  
  =head2 shim_path
  
  interpreter shim path
  
  =head2 init_str
  
  shim initialization string
  
  =head2 env_name
  
  environment name
  
  =head1 METHODS
  
  =head2 BEGIN
  
  Makes sure a configuration directory exists for us to work with
  
  =head2 install_env
  
  Installs the environment or will attempt to upgrade if paths exists
  
  =head2 upgrade_env
  
  Upgrades environments
  
  =head2 cleanup
  
  Cleans up, prints out what you need to add to $SHELL profile. Override
  in respective env classes.
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV_BASE

$fatpacked{"instaenv/Command/i.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV_COMMAND_I';
  package instaenv::Command::i;
  $instaenv::Command::i::VERSION = '0.1';
  # ABSTRACT: play that funky music
  
  use instaenv -command;
  use Class::Load ':all';
  
  use Moo;
  use namespace::clean;
  
  sub opt_spec {
      return (["all", "install all environments [pl,py,rb]envs"]);
  }
  
  sub abstract {'Install all or any supported environments.'}
  
  sub usage_desc {'%c i {py,pl,rb}env'}
  
  sub validate_args {
      my ($self, $opt, $args) = @_;
      $self->usage_error("Don't understand that environment :(")
        unless $opt->{all} || $args->[0] =~ /^plenv|rbenv|pyenv/;
  }
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
      if ($opt->{all}) {
          printf("Installing all envs\n");
      }
      else {
          my $ie = load_class(sprintf('instaenv::Role::%s', ucfirst $args->[0]))->new
            or die "Oh noes! something is wrong with the ship captain: $!\n";
          $ie->install_env;
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv::Command::i - play that funky music
  
  =head1 VERSION
  
  version 0.1
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV_COMMAND_I

$fatpacked{"instaenv/Command/u.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV_COMMAND_U';
  package instaenv::Command::u;
  $instaenv::Command::u::VERSION = '0.1';
  # ABSTRACT: upgrade commands for environments
  
  use instaenv -command;
  use Class::Load ':all';
  
  use Moo;
  use namespace::clean;
  
  sub opt_spec {
      return (["all", "upgrade all environments [pl,py,rb]envs"]);
  }
  
  sub abstract {'Install all or any supported environments.'}
  
  sub usage_desc {'%c i {py,pl,rb}env'}
  
  sub validate_args {
      my ($self, $opt, $args) = @_;
      $self->usage_error("Don't understand that environment :(")
        unless $opt->{all} || $args->[0] =~ /^plenv|rbenv|pyenv/;
  }
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
      if ($opt->{all}) {
          printf("Installing all envs\n");
      }
      else {
          my $ie = load_class(sprintf('instaenv::Role::%s', ucfirst $args->[0]))->new
            or die "Oh noes! something is wrong with the ship captain: $!\n";
          $ie->upgrade_env;
      }
  }
  
  1;
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv::Command::u - upgrade commands for environments
  
  =head1 VERSION
  
  version 0.1
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV_COMMAND_U

$fatpacked{"instaenv/Role/Plenv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV_ROLE_PLENV';
  package instaenv::Role::Plenv;
  $instaenv::Role::Plenv::VERSION = '0.1';
  # ABSTRACT: plenv role
  
  use Path::Tiny;
  use Moo;
  use namespace::clean;
  extends('instaenv::Base');
  
  has '+install_path' => (
      is      => 'ro',
      default => sub {
          my $self = shift;
          {   repo => 'git://github.com/tokuhirom/plenv.git',
              dst  => path("~/.plenv")
          };
      }
  );
  
  has '+plugin' => (
      is      => 'ro',
      default => sub {
          my $self = shift;
          {   repo => 'git://github.com/tokuhirom/Perl-Build.git',
              dst  => $self->install_path->{dst}->child('plugins/perl-build')
          };
      }
  );
  
  has '+interpreter' => (
      is      => 'ro',
      default => 'perl'
  );
  
  has '+shim_path' => (
      is      => 'ro',
      default => 'export PATH="$HOME"/.plenv/bin:$PATH'
  );
  
  has '+init_str' => (
      is      => 'ro',
      default => 'eval "$(plenv init -)"'
  );
  
  has '+env_name' => (
      is      => 'ro',
      default => 'plenv'
  );
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv::Role::Plenv - plenv role
  
  =head1 VERSION
  
  version 0.1
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV_ROLE_PLENV

$fatpacked{"instaenv/Role/Pyenv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV_ROLE_PYENV';
  package instaenv::Role::Pyenv;
  $instaenv::Role::Pyenv::VERSION = '0.1';
  # ABSTRACT: pyenv role
  
  use Path::Tiny;
  
  use Moo;
  use namespace::clean;
  extends('instaenv::Base');
  
  has '+install_path' => (
      is      => 'ro',
      default => sub {
          my $self = shift;
          {   repo => 'git://github.com/yyuu/pyenv.git ~/.pyenv',
              dst  => path("~/.pyenv")
          };
      }
  );
  
  has '+plugin' => (
      is      => 'ro',
      default => sub {
          my $self = shift;
          {   repo => 'git://github.com/yyuu/pyenv-virtualenv.git',
              dst =>
                $self->install_path->{dst}->child('plugins/pyenv-virtualenv')
          };
      }
  );
  
  has '+interpreter' => (
      is      => 'ro',
      default => 'python'
  );
  
  has '+shim_path' => (
      is      => 'ro',
      default => 'export PATH="$HOME"/.pyenv/bin:$PATH'
  );
  
  has '+init_str' => (
      is      => 'ro',
      default => 'eval "$(pyenv init -)"'
  );
  
  has '+env_name' => (
      is      => 'ro',
      default => 'pyenv'
  );
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv::Role::Pyenv - pyenv role
  
  =head1 VERSION
  
  version 0.1
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV_ROLE_PYENV

$fatpacked{"instaenv/Role/Rbenv.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'INSTAENV_ROLE_RBENV';
  package instaenv::Role::Rbenv;
  $instaenv::Role::Rbenv::VERSION = '0.1';
  # ABSTRACT: rbenv role
  
  use Path::Tiny;
  
  use Moo;
  use namespace::clean;
  extends('instaenv::Base');
  
  has '+install_path' => (
      is      => 'ro',
      default => sub {
          my $self = shift;
          {   repo => 'git://github.com/sstephenson/rbenv.git',
              dst  => path("~/.rbenv")
          };
      }
  );
  
  has '+plugin' => (
      is      => 'ro',
      default => sub {
          my $self = shift;
          {   repo => 'git://github.com/sstephenson/ruby-build.git',
              dst  => $self->install_path->{dst}->child('plugins/ruby-build')
          };
      }
  );
  
  has '+interpreter' => (
      is      => 'ro',
      default => 'ruby'
  );
  
  has '+shim_path' => (
      is      => 'ro',
      default => 'export PATH="$HOME"/.rbenv/bin:$PATH'
  );
  
  has '+init_str' => (
      is      => 'ro',
      default => 'eval "$(rbenv init -)"'
  );
  
  has '+env_name' => (
      is      => 'ro',
      default => 'rbenv'
  );
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  instaenv::Role::Rbenv - rbenv role
  
  =head1 VERSION
  
  version 0.1
  
  =head1 AUTHOR
  
  Adam Stokes <adamjs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Stokes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
  WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
  PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
  EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
  SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
  THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
  TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
  CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
  SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGES.
  
  =cut
INSTAENV_ROLE_RBENV

$fatpacked{"x86_64-linux/Class/Load/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_CLASS_LOAD_XS';
  package Class::Load::XS;
  BEGIN {
    $Class::Load::XS::AUTHORITY = 'cpan:SARTAK';
  }
  # git description: v0.07-5-gd41f383
  $Class::Load::XS::VERSION = '0.08';
  
  use strict;
  use warnings;
  
  use Class::Load 0.20;
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      exists $Class::Load::XS::{VERSION}
      ? ${ $Class::Load::XS::{VERSION} }
      : (),
  );
  
  1;
  
  # ABSTRACT: XS implementation of parts of Class::Load
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Load::XS - XS implementation of parts of Class::Load
  
  =head1 VERSION
  
  version 0.08
  
  =head1 SYNOPSIS
  
      use Class::Load;
  
  =head1 DESCRIPTION
  
  This module provides an XS implementation for portions of L<Class::Load>. See
  L<Class::Load> for API details.
  
  =for Pod::Coverage is_class_loaded
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2011 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =back
  
  =cut
X86_64-LINUX_CLASS_LOAD_XS

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.38";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 $b = any { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 $b = all { BLOCK } @list
  
  Similar to C<any>, except that it requires all elements of the C<@list> to make
  the C<BLOCK> return true. If any element returns false, then it returns false.
  If the C<BLOCK> never returns false or the C<@list> was empty then it returns
  true.
  
  =head2 $b = none { BLOCK } @list
  
  =head2 $b = notall { BLOCK } @list
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true only if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true only if not all of the values do.
  
  =head2 $val = first { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 $num = max @list
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 $str = maxstr @list
  
  Similar to C<max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 $num = min @list
  
  Similar to C<max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 $str = minstr @list
  
  Similar to C<min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 $num = product @list
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 $num_or_undef = sum @list
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 $num = sum0 @list
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather than
  C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  =cut
  
  =head2 @kvlist = pairgrep { BLOCK } @kvlist
  
  =head2 $count = pairgrep { BLOCK } @kvlist
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 ( $key, $val ) = pairfirst { BLOCK } @kvlist
  
  =head2 $found = pairfirst { BLOCK } @kvlist
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @list = pairmap { BLOCK } @kvlist
  
  =head2 $count = pairmap { BLOCK } @kvlist
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @pairs = pairs @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 @keys = pairkeys @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 @values = pairvalues @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 @values = shuffle @values
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.38";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.07';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  # Use a private pure-perl copy of looks_like_number if the version of
  # Scalar::Util is old (for whatever reason).
  my $SU = eval "$Scalar::Util::VERSION" || 0;
  if ( $SU >= 1.18 ) { 
  	Scalar::Util->import('looks_like_number');
  } else {
  	eval <<'END_PERL';
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  }
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _CLASSDOES $string, $role
  
  This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSDOES;
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =head2 _INSTANCEDOES $object, $role
  
  This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
  >> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
  5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
  implemented.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCEDOES;
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
X86_64-LINUX_PARAMS_UTIL

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted
  );
  our $VERSION    = "1.38";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 $pkg = blessed( $ref )
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 $addr = refaddr( $ref )
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 $type = reftype( $ref )
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken( REF )
  
  The lvalue C<REF> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken( REF )
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  C<weaken()>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 $weak = isweak( $ref )
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 $var = dualvar( $num, $string )
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 $dual = isdual( $var )
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 $vstring = isvstring( $var )
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 $isnum = looks_like_number( $var )
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 $fh = openhandle( $fh )
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 $ro = readonly( $var )
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 $code = set_prototype( $code, $prototype )
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 $t = tainted( $var )
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX_SUB_NAME

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

# PODNAME: instaenv
# ABSTRACT: magic

use strict;
use warnings;

use instaenv;
instaenv->run;
